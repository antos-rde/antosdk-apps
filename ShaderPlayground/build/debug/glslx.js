(function(){var ah=Object.create||function(a){return{__proto__:a}};function ph(a,b){a.prototype=ah(b.prototype),a.prototype.constructor=a}var qh=Math.imul||function(a,b){return (a*(b>>>16)<<16)+a*(b&65535)|0};var Xe;function rh(a){return typeof a==='string'}function sh(a){return a===null?a:a+''}function Ue(c,a,b){return c.a=a,c.b=b,c.c=a.length,c}function Ve(c){if(c.b>=c.c)return-1;var a=c.a.charCodeAt((c.b=c.b+1|0)-1|0);if(a&64512^55296)return a;if(c.b>=c.c)return-1;var b=c.a.charCodeAt((c.b=c.b+1|0)-1|0);return ((a<<10)+b|0)-56613888|0}function sc(a){return a.c=a.c+1|0,a.c}function Sc(p,a){switch(a){case 0:var b={};return Array.from(p.b.keys()).forEach(function(c){b[c]=p.b.get(c)}),JSON.stringify({shaders:p.a?p.a.map(function(d){return{name:d.a,contents:d.b}}):null,renaming:b},null,2)+'\n';case 1:if(p.a){for(var e='',C=0,B=p.a,U=B.length;C<U;C=C+1|0){var f=B[C];e+='export const GLSLX_SOURCE_'+f.a.replace(new RegExp('([a-z0-9])([A-Z])','g'),'$1_$2').toUpperCase()+' = '+JSON.stringify(f.b)+'\n'}if(p.b&&Array.from(p.b.keys()).length){
e+='\n';for(var F=0,Q=Array.from(p.b.keys()),ia=Q.length;F<ia;F=F+1|0){var h=Q[F];e+='export const GLSLX_NAME_'+h.replace(new RegExp('([a-z0-9])([A-Z])','g'),'$1_$2').toUpperCase()+' = '+JSON.stringify(p.b.get(h))+'\n'}}return e}break;case 2:if(p.a){var m='';m+='#ifndef GLSLX_STRINGS_H\n',m+='#define GLSLX_STRINGS_H\n',m+='\n';for(var M=0,ha=p.a,Z=ha.length;M<Z;M=M+1|0){var l=ha[M];m+='static const char *GLSLX_SOURCE_'+l.a.replace(new RegExp('([a-z0-9])([A-Z])','g'),'$1_$2').toUpperCase()+' = '+JSON.stringify(l.b)+';\n'}if(m+='\n',p.b){for(var $=0,ca=Array.from(p.b.keys()),ua=ca.length;$<ua;$=$+1|0){var g=ca[$];m+='static const char *GLSLX_NAME_'+g.replace(new RegExp('([a-z0-9])([A-Z])','g'),'$1_$2').toUpperCase()+' = '+JSON.stringify(p.b.get(g))+';\n'}m+='\n'}return m+='#endif\n',m}break;case 3:if(p.a){for(var i='',aa=0,ka=p.a,va=ka.length;aa<va;aa=aa+1|0){var o=ka[aa];i+='const GLSLX_SOURCE_'+o.a.replace(new RegExp('([a-z0-9])([A-Z])','g'),'$1_$2').toUpperCase()+' = '+JSON.stringify(o.b)+'\n'}if(p.b&&Array.from(p.b.keys()).length){
i+='\n';for(var Ua=0,la=Array.from(p.b.keys()),rb=la.length;Ua<rb;Ua=Ua+1|0){var k=la[Ua];i+='const GLSLX_NAME_'+k.replace(new RegExp('([a-z0-9])([A-Z])','g'),'$1_$2').toUpperCase()+' = '+JSON.stringify(p.b.get(k))+'\n'}}return i}break;case 4:if(p.a){for(var r='',La=0,Va=p.a,wa=Va.length;La<wa;La=La+1|0){var s=Va[La];r+='pub static GLSLX_SOURCE_'+s.a.replace(new RegExp('([a-z0-9])([A-Z])','g'),'$1_$2').toUpperCase()+': &str = '+JSON.stringify(s.b)+';\n'}if(p.b&&Array.from(p.b.keys()).length){r+='\n';for(var xa=0,eb=Array.from(p.b.keys()),Ia=eb.length;xa<Ia;xa=xa+1|0){var w=eb[xa];r+='pub static GLSLX_NAME_'+w.replace(new RegExp('([a-z0-9])([A-Z])','g'),'$1_$2').toUpperCase()+': &str = '+JSON.stringify(p.b.get(w))+';\n'}}return r}break}return null}function _e(a,b,c){if(a.c)return null;b.unshift(new Xh('<api>',"\nimport {\n  // The variable `gl_Position` is available only in the vertex language and is intended for writing the\n  // homogeneous vertex position. This value will be used by primitive assembly, clipping, culling, and other\n  // fixed functionality operations that operate on primitives after vertex processing has occurred.\n  //\n  // All executions of a well-formed vertex shader should write a value into this variable. It can be\n  // written at any time during shader execution. It may also be read back by the shader after being written.\n  // Compilers may generate a diagnostic message if they detect `gl_Position` is not written, or read before\n  // being written, but not all such cases are detectable. The value of `gl_Position` is undefined if a vertex\n  // shader is executed and does not write `gl_Position`.\n  highp vec4 gl_Position;\n\n  // The variable `gl_PointSize` is available only in the vertex language and is intended for\n  // a vertex shader to write the size of the point to be rasterized. It is measured in pixels.\n  mediump float gl_PointSize;\n\n  const int gl_MaxVertexAttribs;\n  const int gl_MaxVertexUniformVectors;\n  const int gl_MaxVaryingVectors;\n  const int gl_MaxVertexTextureImageUnits;\n  const int gl_MaxCombinedTextureImageUnits;\n  const int gl_MaxTextureImageUnits;\n  const int gl_MaxFragmentUniformVectors;\n  const int gl_MaxDrawBuffers;\n\n  // The fragment shader has access to the read-only built-in variable `gl_FrontFacing` whose value is `true` if\n  // the fragment belongs to a front-facing primitive. One use of this is to emulate two-sided lighting by\n  // selecting one of two colors calculated by the vertex shader.\n  const bool gl_FrontFacing;\n\n  // The fragment shader has access to the read-only built-in variable `gl_PointCoord`. The values in\n  // `gl_PointCoord` are two-dimensional coordinates indicating where within a point primitive the current\n  // fragment is located. They range from 0.0 to 1.0 across the point. If the current primitive is not a\n  // point, then the values read from `gl_PointCoord` are undefined.\n  const mediump vec2 gl_PointCoord;\n\n  // The variable `gl_FragCoord` is available as a read-only variable from within fragment shaders and it holds\n  // the window relative coordinates `x`, `y`, `z`, and `1/w` values for the fragment. This value is the result\n  // of the fixed functionality that interpolates primitives after vertex processing to generate fragments. The `z`\n  // component is the depth value that will be used for the fragment's depth.\n  const mediump vec4 gl_FragCoord;\n\n  // Writing to `gl_FragColor` specifies the fragment color that will be used by the subsequent fixed\n  // functionality pipeline.\n  //\n  // If subsequent fixed functionality consumes fragment color and an execution of a fragment shader\n  // does not write a value to `gl_FragColor` then the fragment color consumed is undefined.\n  mediump vec4 gl_FragColor;\n\n  // The variable `gl_FragData` is an array. Writing to `gl_FragData[n]` specifies the fragment data that will be\n  // used by the subsequent fixed functionality pipeline for data `n`.\n  //\n  // If subsequent fixed functionality consumes fragment data and an execution of a fragment shader does not write\n  // a value to it, then the fragment data consumed is undefined.\n  mediump vec4 gl_FragData[gl_MaxDrawBuffers];\n\n  // Depth range in window coordinates\n  struct gl_DepthRangeParameters {\n    float near;\n    float far;\n    // Equal to `far - near`\n    float diff;\n  };\n\n  uniform gl_DepthRangeParameters gl_DepthRange;\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Angle and Trigonometry Functions\n\n  // Converts `degrees` to radians, i.e. `π / 180 * degrees`\n  float radians(float degrees);\n  // Converts `degrees` to radians, i.e. `π / 180 * degrees`\n  vec2 radians(vec2 degrees);\n  // Converts `degrees` to radians, i.e. `π / 180 * degrees`\n  vec3 radians(vec3 degrees);\n  // Converts `degrees` to radians, i.e. `π / 180 * degrees`\n  vec4 radians(vec4 degrees);\n\n  // Converts `radians` to degrees, i.e. `180 / π * radians`\n  float degrees(float radians);\n  // Converts `radians` to degrees, i.e. `180 / π * radians`\n  vec2 degrees(vec2 radians);\n  // Converts `radians` to degrees, i.e. `180 / π * radians`\n  vec3 degrees(vec3 radians);\n  // Converts `radians` to degrees, i.e. `180 / π * radians`\n  vec4 degrees(vec4 radians);\n\n  // The standard trigonometric sine function.\n  float sin(float angle);\n  // The standard trigonometric sine function.\n  vec2 sin(vec2 angle);\n  // The standard trigonometric sine function.\n  vec3 sin(vec3 angle);\n  // The standard trigonometric sine function.\n  vec4 sin(vec4 angle);\n\n  // The standard trigonometric cosine function.\n  float cos(float angle);\n  // The standard trigonometric cosine function.\n  vec2 cos(vec2 angle);\n  // The standard trigonometric cosine function.\n  vec3 cos(vec3 angle);\n  // The standard trigonometric cosine function.\n  vec4 cos(vec4 angle);\n\n  // The standard trigonometric tangent.\n  float tan(float angle);\n  // The standard trigonometric tangent.\n  vec2 tan(vec2 angle);\n  // The standard trigonometric tangent.\n  vec3 tan(vec3 angle);\n  // The standard trigonometric tangent.\n  vec4 tan(vec4 angle);\n\n  // Arc sine. Returns an angle whose sine is `x`. The range of values returned by this function is `[-π/2, π/2]`. Results are undefined if `∣x∣>1`.\n  float asin(float x);\n  // Arc sine. Returns an angle whose sine is `x`. The range of values returned by this function is `[-π/2, π/2]`. Results are undefined if `∣x∣>1`.\n  vec2 asin(vec2 x);\n  // Arc sine. Returns an angle whose sine is `x`. The range of values returned by this function is `[-π/2, π/2]`. Results are undefined if `∣x∣>1`.\n  vec3 asin(vec3 x);\n  // Arc sine. Returns an angle whose sine is `x`. The range of values returned by this function is `[-π/2, π/2]`. Results are undefined if `∣x∣>1`.\n  vec4 asin(vec4 x);\n\n  // Arc cosine. Returns an angle whose cosine is `x`. The range of values returned by this function is `[0, π]`. Results are undefined if `∣x∣>1`.\n  float acos(float x);\n  // Arc cosine. Returns an angle whose cosine is `x`. The range of values returned by this function is `[0, π]`. Results are undefined if `∣x∣>1`.\n  vec2 acos(vec2 x);\n  // Arc cosine. Returns an angle whose cosine is `x`. The range of values returned by this function is `[0, π]`. Results are undefined if `∣x∣>1`.\n  vec3 acos(vec3 x);\n  // Arc cosine. Returns an angle whose cosine is `x`. The range of values returned by this function is `[0, π]`. Results are undefined if `∣x∣>1`.\n  vec4 acos(vec4 x);\n\n  // Arc tangent. Returns an angle whose tangent is `y/x`. The signs of `x` and `y` are used to determine what quadrant the\n  // angle is in. The range of values returned by this function is `[−π,π]`. Results are undefined if `x` and `y` are both 0.\n  float atan(float y, float x);\n  // Arc tangent. Returns an angle whose tangent is `y/x`. The signs of `x` and `y` are used to determine what quadrant the\n  // angle is in. The range of values returned by this function is `[−π,π]`. Results are undefined if `x` and `y` are both 0.\n  vec2 atan(vec2 y, vec2 x);\n  // Arc tangent. Returns an angle whose tangent is `y/x`. The signs of `x` and `y` are used to determine what quadrant the\n  // angle is in. The range of values returned by this function is `[−π,π]`. Results are undefined if `x` and `y` are both 0.\n  vec3 atan(vec3 y, vec3 x);\n  // Arc tangent. Returns an angle whose tangent is `y/x`. The signs of `x` and `y` are used to determine what quadrant the\n  // angle is in. The range of values returned by this function is `[−π,π]`. Results are undefined if `x` and `y` are both 0.\n  vec4 atan(vec4 y, vec4 x);\n\n  // Arc tangent. Returns an angle whose tangent is `y_over_x`. The range of values returned by this function is `[-π/2, π/2]`.\n  float atan(float y_over_x);\n  // Arc tangent. Returns an angle whose tangent is `y_over_x`. The range of values returned by this function is `[-π/2, π/2]`.\n  vec2 atan(vec2 y_over_x);\n  // Arc tangent. Returns an angle whose tangent is `y_over_x`. The range of values returned by this function is `[-π/2, π/2]`.\n  vec3 atan(vec3 y_over_x);\n  // Arc tangent. Returns an angle whose tangent is `y_over_x`. The range of values returned by this function is `[-π/2, π/2]`.\n  vec4 atan(vec4 y_over_x);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Exponential Functions\n\n  // Returns `x` raised to the `y` power, i.e., `xʸ`. Results are undefined if `x < 0`. Results are undefined if `x = 0` and `y <= 0`.\n  float pow(float x, float y);\n  // Returns `x` raised to the `y` power, i.e., `xʸ`. Results are undefined if `x < 0`. Results are undefined if `x = 0` and `y <= 0`.\n  vec2 pow(vec2 x, vec2 y);\n  // Returns `x` raised to the `y` power, i.e., `xʸ`. Results are undefined if `x < 0`. Results are undefined if `x = 0` and `y <= 0`.\n  vec3 pow(vec3 x, vec3 y);\n  // Returns `x` raised to the `y` power, i.e., `xʸ`. Results are undefined if `x < 0`. Results are undefined if `x = 0` and `y <= 0`.\n  vec4 pow(vec4 x, vec4 y);\n\n  // Returns the natural exponentiation of `x`, i.e., `eˣ`\n  float exp(float x);\n  // Returns the natural exponentiation of `x`, i.e., `eˣ`\n  vec2 exp(vec2 x);\n  // Returns the natural exponentiation of `x`, i.e., `eˣ`\n  vec3 exp(vec3 x);\n  // Returns the natural exponentiation of `x`, i.e., `eˣ`\n  vec4 exp(vec4 x);\n\n  // Returns the natural logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = eʸ`. Results are undefined if `x <= 0`.\n  float log(float x);\n  // Returns the natural logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = eʸ`. Results are undefined if `x <= 0`.\n  vec2 log(vec2 x);\n  // Returns the natural logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = eʸ`. Results are undefined if `x <= 0`.\n  vec3 log(vec3 x);\n  // Returns the natural logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = eʸ`. Results are undefined if `x <= 0`.\n  vec4 log(vec4 x);\n\n  // Returns 2 raised to the `x` power, i.e., `2ˣ`.\n  float exp2(float x);\n  // Returns 2 raised to the `x` power, i.e., `2ˣ`.\n  vec2 exp2(vec2 x);\n  // Returns 2 raised to the `x` power, i.e., `2ˣ`.\n  vec3 exp2(vec3 x);\n  // Returns 2 raised to the `x` power, i.e., `2ˣ`.\n  vec4 exp2(vec4 x);\n\n  // Returns the base 2 logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = 2ʸ`. Results are undefined if `x <= 0`.\n  float log2(float x);\n  // Returns the base 2 logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = 2ʸ`. Results are undefined if `x <= 0`.\n  vec2 log2(vec2 x);\n  // Returns the base 2 logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = 2ʸ`. Results are undefined if `x <= 0`.\n  vec3 log2(vec3 x);\n  // Returns the base 2 logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = 2ʸ`. Results are undefined if `x <= 0`.\n  vec4 log2(vec4 x);\n\n  // Returns `√x`. Results are undefined if `x < 0`.\n  float sqrt(float x);\n  // Returns `√x`. Results are undefined if `x < 0`.\n  vec2 sqrt(vec2 x);\n  // Returns `√x`. Results are undefined if `x < 0`.\n  vec3 sqrt(vec3 x);\n  // Returns `√x`. Results are undefined if `x < 0`.\n  vec4 sqrt(vec4 x);\n\n  // Returns `1 / √x`. Results are undefined if `x <= 0`.\n  float inversesqrt(float x);\n  // Returns `1 / √x`. Results are undefined if `x <= 0`.\n  vec2 inversesqrt(vec2 x);\n  // Returns `1 / √x`. Results are undefined if `x <= 0`.\n  vec3 inversesqrt(vec3 x);\n  // Returns `1 / √x`. Results are undefined if `x <= 0`.\n  vec4 inversesqrt(vec4 x);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Common Functions\n\n  // Returns `x` if `x >= 0`, otherwise it returns `-x`.\n  float abs(float x);\n  // Returns `x` if `x >= 0`, otherwise it returns `-x`.\n  vec2 abs(vec2 x);\n  // Returns `x` if `x >= 0`, otherwise it returns `-x`.\n  vec3 abs(vec3 x);\n  // Returns `x` if `x >= 0`, otherwise it returns `-x`.\n  vec4 abs(vec4 x);\n\n  // Returns `1.0` if `x > 0`, `0.0` if `x = 0`, or `-1.0` if `x < 0`\n  float sign(float x);\n  // Returns `1.0` if `x > 0`, `0.0` if `x = 0`, or `-1.0` if `x < 0`\n  vec2 sign(vec2 x);\n  // Returns `1.0` if `x > 0`, `0.0` if `x = 0`, or `-1.0` if `x < 0`\n  vec3 sign(vec3 x);\n  // Returns `1.0` if `x > 0`, `0.0` if `x = 0`, or `-1.0` if `x < 0`\n  vec4 sign(vec4 x);\n\n  // Returns a value equal to the nearest integer that is less than or equal to `x`\n  float floor(float x);\n  // Returns a value equal to the nearest integer that is less than or equal to `x`\n  vec2 floor(vec2 x);\n  // Returns a value equal to the nearest integer that is less than or equal to `x`\n  vec3 floor(vec3 x);\n  // Returns a value equal to the nearest integer that is less than or equal to `x`\n  vec4 floor(vec4 x);\n\n  // Returns a value equal to the nearest integer that is greater than or equal to `x`\n  float ceil(float x);\n  // Returns a value equal to the nearest integer that is greater than or equal to `x`\n  vec2 ceil(vec2 x);\n  // Returns a value equal to the nearest integer that is greater than or equal to `x`\n  vec3 ceil(vec3 x);\n  // Returns a value equal to the nearest integer that is greater than or equal to `x`\n  vec4 ceil(vec4 x);\n\n  // Returns `x - floor(x)`\n  float fract(float x);\n  // Returns `x - floor(x)`\n  vec2 fract(vec2 x);\n  // Returns `x - floor(x)`\n  vec3 fract(vec3 x);\n  // Returns `x - floor(x)`\n  vec4 fract(vec4 x);\n\n  // Modulus (modulo). Returns `x - y * floor(x/y)`\n  float mod(float x, float y);\n  // Modulus (modulo). Returns `x - y * floor(x/y)`\n  vec2 mod(vec2 x, float y);\n  // Modulus (modulo). Returns `x - y * floor(x/y)`\n  vec3 mod(vec3 x, float y);\n  // Modulus (modulo). Returns `x - y * floor(x/y)`\n  vec4 mod(vec4 x, float y);\n\n  // Modulus. Returns `x - y * floor(x/y)`\n  vec2 mod(vec2 x, vec2 y);\n  // Modulus. Returns `x - y * floor(x/y)`\n  vec3 mod(vec3 x, vec3 y);\n  // Modulus. Returns `x - y * floor(x/y)`\n  vec4 mod(vec4 x, vec4 y);\n\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  float min(float x, float y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec2 min(vec2 x, float y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec2 min(vec2 x, vec2 y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec3 min(vec3 x, float y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec3 min(vec3 x, vec3 y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec4 min(vec4 x, float y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec4 min(vec4 x, vec4 y);\n\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  float max(float x, float y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec2 max(vec2 x, float y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec2 max(vec2 x, vec2 y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec3 max(vec3 x, float y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec3 max(vec3 x, vec3 y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec4 max(vec4 x, float y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec4 max(vec4 x, vec4 y);\n\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  float clamp(float x, float minVal, float maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec2 clamp(vec2 x, float minVal, float maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec2 clamp(vec2 x, vec2 minVal, vec2 maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec3 clamp(vec3 x, float minVal, float maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec3 clamp(vec3 x, vec3 minVal, vec3 maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec4 clamp(vec4 x, float minVal, float maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec4 clamp(vec4 x, vec4 minVal, vec4 maxVal);\n\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  float mix(float x, float y, float a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec2 mix(vec2 x, vec2 y, float a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec2 mix(vec2 x, vec2 y, vec2 a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec3 mix(vec3 x, vec3 y, float a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec3 mix(vec3 x, vec3 y, vec3 a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec4 mix(vec4 x, vec4 y, float a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec4 mix(vec4 x, vec4 y, vec4 a);\n\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  float step(float edge, float x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec2 step(float edge, vec2 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec2 step(vec2 edge, vec2 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec3 step(float edge, vec3 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec3 step(vec3 edge, vec3 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec4 step(float edge, vec4 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec4 step(vec4 edge, vec4 x);\n\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  float smoothstep(float edge0, float edge1, float x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec2 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec2 smoothstep(float edge0, float edge1, vec2 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec2 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec3 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec3 smoothstep(float edge0, float edge1, vec3 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec3 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec4 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec4 smoothstep(float edge0, float edge1, vec4 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec4 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Geometric Functions\n\n  // Returns the length of vector `x`, i.e. `√x²`\n  float length(float x);\n  // Returns the length of vector `x`, i.e. `√x[0]² + x[1]²`\n  float length(vec2 x);\n  // Returns the length of vector `x`, i.e. `√x[0]² + x[1]² + x[2]²`\n  float length(vec3 x);\n  // Returns the length of vector `x`, i.e. `√x[0]² + x[1]² + x[2]² + x[3]²`\n  float length(vec4 x);\n\n  // Returns the distance between `p0` and `p1`, i.e. `length(p0 - p1)`\n  float distance(float p0, float p1);\n  // Returns the distance between `p0` and `p1`, i.e. `length(p0 - p1)`\n  float distance(vec2 p0, vec2 p1);\n  // Returns the distance between `p0` and `p1`, i.e. `length(p0 - p1)`\n  float distance(vec3 p0, vec3 p1);\n  // Returns the distance between `p0` and `p1`, i.e. `length(p0 - p1)`\n  float distance(vec4 p0, vec4 p1);\n\n  // Returns the dot product of `x` and `y`, i.e. `x*y`\n  float dot(float x, float y);\n  // Returns the dot product of `x` and `y`, i.e. `x[0]*y[0] + x[1]*y[1]`\n  float dot(vec2 x, vec2 y);\n  // Returns the dot product of `x` and `y`, i.e. `x[0]*y[0] + x[1]*y[1] + x[2]*y[2]`\n  float dot(vec3 x, vec3 y);\n  // Returns the dot product of `x` and `y`, i.e. `x[0]*y[0] + x[1]*y[1] + x[2]*y[2] + x[3]*y[3]`\n  float dot(vec4 x, vec4 y);\n\n  // Returns the cross product of `x` and `y`, i.e.\n  //\n  // ```glslx\n  // vec3(\n  //   x[1]*y[2] - y[1]*x[2],\n  //   x[2]*y[0] - y[2]*x[0],\n  //   x[0]*y[1] - y[0]*x[1])\n  // ```\n  vec3 cross(vec3 x, vec3 y);\n\n  // Returns a vector in the same direction as `x` but with a length of 1.\n  float normalize(float x);\n  // Returns a vector in the same direction as `x` but with a length of 1.\n  vec2 normalize(vec2 x);\n  // Returns a vector in the same direction as `x` but with a length of 1.\n  vec3 normalize(vec3 x);\n  // Returns a vector in the same direction as `x` but with a length of 1.\n  vec4 normalize(vec4 x);\n\n  // If `dot(Nref, I) < 0` return `N`, otherwise return `-N`\n  float faceforward(float N, float I, float Nref);\n  // If `dot(Nref, I) < 0` return `N`, otherwise return `-N`\n  vec2 faceforward(vec2 N, vec2 I, vec2 Nref);\n  // If `dot(Nref, I) < 0` return `N`, otherwise return `-N`\n  vec3 faceforward(vec3 N, vec3 I, vec3 Nref);\n  // If `dot(Nref, I) < 0` return `N`, otherwise return `-N`\n  vec4 faceforward(vec4 N, vec4 I, vec4 Nref);\n\n  // For the incident vector `I` and surface orientation `N`, returns the reflection direction: `I - 2 * dot(N, I) * N`.\n  // `N` must already be normalized in order to achieve the desired result.\n  float reflect(float I, float N);\n  // For the incident vector `I` and surface orientation `N`, returns the reflection direction: `I - 2 * dot(N, I) * N`.\n  // `N` must already be normalized in order to achieve the desired result.\n  vec2 reflect(vec2 I, vec2 N);\n  // For the incident vector `I` and surface orientation `N`, returns the reflection direction: `I - 2 * dot(N, I) * N`.\n  // `N` must already be normalized in order to achieve the desired result.\n  vec3 reflect(vec3 I, vec3 N);\n  // For the incident vector `I` and surface orientation `N`, returns the reflection direction: `I - 2 * dot(N, I) * N`.\n  // `N` must already be normalized in order to achieve the desired result.\n  vec4 reflect(vec4 I, vec4 N);\n\n  // For the incident vector `I` and surface normal `N`, and the ratio of indices of refraction `eta`, return the refraction vector.\n  // The result is computed by:\n  //\n  // ```glslx\n  // float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n  // if (k < 0.0) return float(0.0);\n  // else return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n  // ```\n  //\n  // The input parameters for the incident vector `I` and the surface normal `N`.\n  float refract(float I, float N, float eta);\n  // For the incident vector `I` and surface normal `N`, and the ratio of indices of refraction `eta`, return the refraction vector.\n  // The result is computed by:\n  //\n  // ```glslx\n  // float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n  // if (k < 0.0) return vec2(0.0);\n  // else return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n  // ```\n  //\n  // The input parameters for the incident vector `I` and the surface normal `N`.\n  vec2 refract(vec2 I, vec2 N, float eta);\n  // For the incident vector `I` and surface normal `N`, and the ratio of indices of refraction `eta`, return the refraction vector.\n  // The result is computed by:\n  //\n  // ```glslx\n  // float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n  // if (k < 0.0) return vec3(0.0);\n  // else return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n  // ```\n  //\n  // The input parameters for the incident vector `I` and the surface normal `N`.\n  vec3 refract(vec3 I, vec3 N, float eta);\n  // For the incident vector `I` and surface normal `N`, and the ratio of indices of refraction `eta`, return the refraction vector.\n  // The result is computed by:\n  //\n  // ```glslx\n  // float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n  // if (k < 0.0) return vec4(0.0);\n  // else return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n  // ```\n  //\n  // The input parameters for the incident vector `I` and the surface normal `N`.\n  vec4 refract(vec4 I, vec4 N, float eta);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Matrix Functions\n\n  // Multiply matrix `x` by matrix `y` component-wise, i.e., `result[i][j]` is the scalar product of `x[i][j]` and `y[i][j]`.\n  // Note: to get linear algebraic matrix multiplication, use the multiply operator (`*`).\n  mat2 matrixCompMult(mat2 x, mat2 y);\n  // Multiply matrix `x` by matrix `y` component-wise, i.e., `result[i][j]` is the scalar product of `x[i][j]` and `y[i][j]`.\n  // Note: to get linear algebraic matrix multiplication, use the multiply operator (`*`).\n  mat3 matrixCompMult(mat3 x, mat3 y);\n  // Multiply matrix `x` by matrix `y` component-wise, i.e., `result[i][j]` is the scalar product of `x[i][j]` and `y[i][j]`.\n  // Note: to get linear algebraic matrix multiplication, use the multiply operator (`*`).\n  mat4 matrixCompMult(mat4 x, mat4 y);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Vector Relational Functions\n\n  // Returns the component-wise compare of `x < y`.\n  bvec2 lessThan(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec2 lessThan(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec3 lessThan(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec3 lessThan(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec4 lessThan(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec4 lessThan(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x <= y`.\n  bvec2 lessThanEqual(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec2 lessThanEqual(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec3 lessThanEqual(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec3 lessThanEqual(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec4 lessThanEqual(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec4 lessThanEqual(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x > y`.\n  bvec2 greaterThan(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec2 greaterThan(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec3 greaterThan(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec3 greaterThan(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec4 greaterThan(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec4 greaterThan(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x >= y`.\n  bvec2 greaterThanEqual(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec2 greaterThanEqual(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec3 greaterThanEqual(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec3 greaterThanEqual(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec4 greaterThanEqual(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec4 greaterThanEqual(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x == y`.\n  bvec2 equal(bvec2 x, bvec2 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec2 equal(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec2 equal(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec3 equal(bvec3 x, bvec3 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec3 equal(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec3 equal(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec4 equal(bvec4 x, bvec4 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec4 equal(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec4 equal(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x != y`.\n  bvec2 notEqual(bvec2 x, bvec2 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec2 notEqual(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec2 notEqual(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec3 notEqual(bvec3 x, bvec3 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec3 notEqual(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec3 notEqual(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec4 notEqual(bvec4 x, bvec4 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec4 notEqual(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec4 notEqual(vec4 x, vec4 y);\n\n  // Returns true if any component of `x` is `true`.\n  bool any(bvec2 x);\n  // Returns true if any component of `x` is `true`.\n  bool any(bvec3 x);\n  // Returns true if any component of `x` is `true`.\n  bool any(bvec4 x);\n\n  // Returns true only if all components of `x` are `true`.\n  bool all(bvec2 x);\n  // Returns true only if all components of `x` are `true`.\n  bool all(bvec3 x);\n  // Returns true only if all components of `x` are `true`.\n  bool all(bvec4 x);\n\n  // Returns the component-wise logical complement of `x`.\n  bvec2 not(bvec2 x);\n  // Returns the component-wise logical complement of `x`.\n  bvec3 not(bvec3 x);\n  // Returns the component-wise logical complement of `x`.\n  bvec4 not(bvec4 x);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Texture Lookup Functions\n\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  vec4 texture2D(sampler2D sampler, vec2 coord);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  vec4 texture2D(sampler2D sampler, vec2 coord, float bias);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`.\n  vec4 texture2DProj(sampler2D sampler, vec3 coord);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`.\n  vec4 texture2DProj(sampler2D sampler, vec3 coord, float bias);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`.\n  vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`. The third component of `coord` is ignored.\n  vec4 texture2DProj(sampler2D sampler, vec4 coord);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`. The third component of `coord` is ignored.\n  vec4 texture2DProj(sampler2D sampler, vec4 coord, float bias);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`. The third component of `coord` is ignored.\n  vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod);\n\n  // Use the texture coordinate `coord` to do a texture lookup in the cube map texture currently bound to `sampler`.\n  // The direction of `coord` is used to select which face to do a 2-dimensional texture lookup in.\n  vec4 textureCube(samplerCube sampler, vec3 coord);\n  // Use the texture coordinate `coord` to do a texture lookup in the cube map texture currently bound to `sampler`.\n  // The direction of `coord` is used to select which face to do a 2-dimensional texture lookup in.\n  vec4 textureCube(samplerCube sampler, vec3 coord, float bias);\n  // Use the texture coordinate `coord` to do a texture lookup in the cube map texture currently bound to `sampler`.\n  // The direction of `coord` is used to select which face to do a 2-dimensional texture lookup in.\n  vec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod);\n\n  #extension GL_OES_standard_derivatives {\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `x` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    float dFdx(float v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `x` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec2 dFdx(vec2 v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `x` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec3 dFdx(vec3 v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `x` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec4 dFdx(vec4 v);\n\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `y` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdy(dFdy(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    float dFdy(float v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `y` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdy(dFdy(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec2 dFdy(vec2 v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `y` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdy(dFdy(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec3 dFdy(vec3 v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `y` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdy(dFdy(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec4 dFdy(vec4 v);\n\n    // Returns the sum of the absolute derivative in `x` and `y` using local differencing for the input argument `p`, i.e. `abs(dFdx(p)) + abs(dFdy(p))`\n    float fwidth(float v);\n    // Returns the sum of the absolute derivative in `x` and `y` using local differencing for the input argument `p`, i.e. `abs(dFdx(p)) + abs(dFdy(p))`\n    vec2 fwidth(vec2 v);\n    // Returns the sum of the absolute derivative in `x` and `y` using local differencing for the input argument `p`, i.e. `abs(dFdx(p)) + abs(dFdy(p))`\n    vec3 fwidth(vec3 v);\n    // Returns the sum of the absolute derivative in `x` and `y` using local differencing for the input argument `p`, i.e. `abs(dFdx(p)) + abs(dFdy(p))`\n    vec4 fwidth(vec4 v);\n  }\n\n  #extension GL_EXT_frag_depth {\n    // Available only in the fragment language, `gl_FragDepthEXT` is an output variable that is used to establish the depth value for the current fragment.\n    // If depth buffering is enabled and no shader writes to `gl_FragDepthEXT`, then the fixed function value for depth will be used (this value is contained\n    // in the `z` component of `gl_FragCoord`) otherwise, the value written to `gl_FragDepthEXT` is used.\n    //\n    // If a shader statically assigns to `gl_FragDepthEXT`, then the value of the fragment's depth may be undefined for executions of the shader that take\n    // that path. That is, if the set of linked fragment shaders statically contain a write to `gl_FragDepthEXT`, then it is responsible for always writing it.\n    float gl_FragDepthEXT;\n  }\n\n  #extension GL_EXT_shader_texture_lod {\n    vec4 texture2DGradEXT(sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\n    vec4 texture2DLodEXT(sampler2D sampler, vec2 coord, float lod);\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec3 coord, float lod);\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec4 coord, float lod);\n    vec4 textureCubeGradEXT(samplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\n    vec4 textureCubeLodEXT(samplerCube sampler, vec3 coord, float lod);\n  }\n}\n"));
for(var o=0,k=b.length;o<k;o=o+1|0){var d=b[o];d.c=Jc(a,d,0)}for(var e=new Jh(0),f=new Vh(1,null),h=new uh(c.e),m=new Th(a,h),l=[],r=0,s=b.length;r<s;r=r+1|0){var g=b[r],i=jd(a,g.c,e,h,f,m);Ze(l,i.a)}return nd(m,e),new wh(e,l)}function Gd(a,b,c){if(a.c)return null;b.unshift(new Xh('<api>',"\nimport {\n  // The variable `gl_Position` is available only in the vertex language and is intended for writing the\n  // homogeneous vertex position. This value will be used by primitive assembly, clipping, culling, and other\n  // fixed functionality operations that operate on primitives after vertex processing has occurred.\n  //\n  // All executions of a well-formed vertex shader should write a value into this variable. It can be\n  // written at any time during shader execution. It may also be read back by the shader after being written.\n  // Compilers may generate a diagnostic message if they detect `gl_Position` is not written, or read before\n  // being written, but not all such cases are detectable. The value of `gl_Position` is undefined if a vertex\n  // shader is executed and does not write `gl_Position`.\n  highp vec4 gl_Position;\n\n  // The variable `gl_PointSize` is available only in the vertex language and is intended for\n  // a vertex shader to write the size of the point to be rasterized. It is measured in pixels.\n  mediump float gl_PointSize;\n\n  const int gl_MaxVertexAttribs;\n  const int gl_MaxVertexUniformVectors;\n  const int gl_MaxVaryingVectors;\n  const int gl_MaxVertexTextureImageUnits;\n  const int gl_MaxCombinedTextureImageUnits;\n  const int gl_MaxTextureImageUnits;\n  const int gl_MaxFragmentUniformVectors;\n  const int gl_MaxDrawBuffers;\n\n  // The fragment shader has access to the read-only built-in variable `gl_FrontFacing` whose value is `true` if\n  // the fragment belongs to a front-facing primitive. One use of this is to emulate two-sided lighting by\n  // selecting one of two colors calculated by the vertex shader.\n  const bool gl_FrontFacing;\n\n  // The fragment shader has access to the read-only built-in variable `gl_PointCoord`. The values in\n  // `gl_PointCoord` are two-dimensional coordinates indicating where within a point primitive the current\n  // fragment is located. They range from 0.0 to 1.0 across the point. If the current primitive is not a\n  // point, then the values read from `gl_PointCoord` are undefined.\n  const mediump vec2 gl_PointCoord;\n\n  // The variable `gl_FragCoord` is available as a read-only variable from within fragment shaders and it holds\n  // the window relative coordinates `x`, `y`, `z`, and `1/w` values for the fragment. This value is the result\n  // of the fixed functionality that interpolates primitives after vertex processing to generate fragments. The `z`\n  // component is the depth value that will be used for the fragment's depth.\n  const mediump vec4 gl_FragCoord;\n\n  // Writing to `gl_FragColor` specifies the fragment color that will be used by the subsequent fixed\n  // functionality pipeline.\n  //\n  // If subsequent fixed functionality consumes fragment color and an execution of a fragment shader\n  // does not write a value to `gl_FragColor` then the fragment color consumed is undefined.\n  mediump vec4 gl_FragColor;\n\n  // The variable `gl_FragData` is an array. Writing to `gl_FragData[n]` specifies the fragment data that will be\n  // used by the subsequent fixed functionality pipeline for data `n`.\n  //\n  // If subsequent fixed functionality consumes fragment data and an execution of a fragment shader does not write\n  // a value to it, then the fragment data consumed is undefined.\n  mediump vec4 gl_FragData[gl_MaxDrawBuffers];\n\n  // Depth range in window coordinates\n  struct gl_DepthRangeParameters {\n    float near;\n    float far;\n    // Equal to `far - near`\n    float diff;\n  };\n\n  uniform gl_DepthRangeParameters gl_DepthRange;\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Angle and Trigonometry Functions\n\n  // Converts `degrees` to radians, i.e. `π / 180 * degrees`\n  float radians(float degrees);\n  // Converts `degrees` to radians, i.e. `π / 180 * degrees`\n  vec2 radians(vec2 degrees);\n  // Converts `degrees` to radians, i.e. `π / 180 * degrees`\n  vec3 radians(vec3 degrees);\n  // Converts `degrees` to radians, i.e. `π / 180 * degrees`\n  vec4 radians(vec4 degrees);\n\n  // Converts `radians` to degrees, i.e. `180 / π * radians`\n  float degrees(float radians);\n  // Converts `radians` to degrees, i.e. `180 / π * radians`\n  vec2 degrees(vec2 radians);\n  // Converts `radians` to degrees, i.e. `180 / π * radians`\n  vec3 degrees(vec3 radians);\n  // Converts `radians` to degrees, i.e. `180 / π * radians`\n  vec4 degrees(vec4 radians);\n\n  // The standard trigonometric sine function.\n  float sin(float angle);\n  // The standard trigonometric sine function.\n  vec2 sin(vec2 angle);\n  // The standard trigonometric sine function.\n  vec3 sin(vec3 angle);\n  // The standard trigonometric sine function.\n  vec4 sin(vec4 angle);\n\n  // The standard trigonometric cosine function.\n  float cos(float angle);\n  // The standard trigonometric cosine function.\n  vec2 cos(vec2 angle);\n  // The standard trigonometric cosine function.\n  vec3 cos(vec3 angle);\n  // The standard trigonometric cosine function.\n  vec4 cos(vec4 angle);\n\n  // The standard trigonometric tangent.\n  float tan(float angle);\n  // The standard trigonometric tangent.\n  vec2 tan(vec2 angle);\n  // The standard trigonometric tangent.\n  vec3 tan(vec3 angle);\n  // The standard trigonometric tangent.\n  vec4 tan(vec4 angle);\n\n  // Arc sine. Returns an angle whose sine is `x`. The range of values returned by this function is `[-π/2, π/2]`. Results are undefined if `∣x∣>1`.\n  float asin(float x);\n  // Arc sine. Returns an angle whose sine is `x`. The range of values returned by this function is `[-π/2, π/2]`. Results are undefined if `∣x∣>1`.\n  vec2 asin(vec2 x);\n  // Arc sine. Returns an angle whose sine is `x`. The range of values returned by this function is `[-π/2, π/2]`. Results are undefined if `∣x∣>1`.\n  vec3 asin(vec3 x);\n  // Arc sine. Returns an angle whose sine is `x`. The range of values returned by this function is `[-π/2, π/2]`. Results are undefined if `∣x∣>1`.\n  vec4 asin(vec4 x);\n\n  // Arc cosine. Returns an angle whose cosine is `x`. The range of values returned by this function is `[0, π]`. Results are undefined if `∣x∣>1`.\n  float acos(float x);\n  // Arc cosine. Returns an angle whose cosine is `x`. The range of values returned by this function is `[0, π]`. Results are undefined if `∣x∣>1`.\n  vec2 acos(vec2 x);\n  // Arc cosine. Returns an angle whose cosine is `x`. The range of values returned by this function is `[0, π]`. Results are undefined if `∣x∣>1`.\n  vec3 acos(vec3 x);\n  // Arc cosine. Returns an angle whose cosine is `x`. The range of values returned by this function is `[0, π]`. Results are undefined if `∣x∣>1`.\n  vec4 acos(vec4 x);\n\n  // Arc tangent. Returns an angle whose tangent is `y/x`. The signs of `x` and `y` are used to determine what quadrant the\n  // angle is in. The range of values returned by this function is `[−π,π]`. Results are undefined if `x` and `y` are both 0.\n  float atan(float y, float x);\n  // Arc tangent. Returns an angle whose tangent is `y/x`. The signs of `x` and `y` are used to determine what quadrant the\n  // angle is in. The range of values returned by this function is `[−π,π]`. Results are undefined if `x` and `y` are both 0.\n  vec2 atan(vec2 y, vec2 x);\n  // Arc tangent. Returns an angle whose tangent is `y/x`. The signs of `x` and `y` are used to determine what quadrant the\n  // angle is in. The range of values returned by this function is `[−π,π]`. Results are undefined if `x` and `y` are both 0.\n  vec3 atan(vec3 y, vec3 x);\n  // Arc tangent. Returns an angle whose tangent is `y/x`. The signs of `x` and `y` are used to determine what quadrant the\n  // angle is in. The range of values returned by this function is `[−π,π]`. Results are undefined if `x` and `y` are both 0.\n  vec4 atan(vec4 y, vec4 x);\n\n  // Arc tangent. Returns an angle whose tangent is `y_over_x`. The range of values returned by this function is `[-π/2, π/2]`.\n  float atan(float y_over_x);\n  // Arc tangent. Returns an angle whose tangent is `y_over_x`. The range of values returned by this function is `[-π/2, π/2]`.\n  vec2 atan(vec2 y_over_x);\n  // Arc tangent. Returns an angle whose tangent is `y_over_x`. The range of values returned by this function is `[-π/2, π/2]`.\n  vec3 atan(vec3 y_over_x);\n  // Arc tangent. Returns an angle whose tangent is `y_over_x`. The range of values returned by this function is `[-π/2, π/2]`.\n  vec4 atan(vec4 y_over_x);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Exponential Functions\n\n  // Returns `x` raised to the `y` power, i.e., `xʸ`. Results are undefined if `x < 0`. Results are undefined if `x = 0` and `y <= 0`.\n  float pow(float x, float y);\n  // Returns `x` raised to the `y` power, i.e., `xʸ`. Results are undefined if `x < 0`. Results are undefined if `x = 0` and `y <= 0`.\n  vec2 pow(vec2 x, vec2 y);\n  // Returns `x` raised to the `y` power, i.e., `xʸ`. Results are undefined if `x < 0`. Results are undefined if `x = 0` and `y <= 0`.\n  vec3 pow(vec3 x, vec3 y);\n  // Returns `x` raised to the `y` power, i.e., `xʸ`. Results are undefined if `x < 0`. Results are undefined if `x = 0` and `y <= 0`.\n  vec4 pow(vec4 x, vec4 y);\n\n  // Returns the natural exponentiation of `x`, i.e., `eˣ`\n  float exp(float x);\n  // Returns the natural exponentiation of `x`, i.e., `eˣ`\n  vec2 exp(vec2 x);\n  // Returns the natural exponentiation of `x`, i.e., `eˣ`\n  vec3 exp(vec3 x);\n  // Returns the natural exponentiation of `x`, i.e., `eˣ`\n  vec4 exp(vec4 x);\n\n  // Returns the natural logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = eʸ`. Results are undefined if `x <= 0`.\n  float log(float x);\n  // Returns the natural logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = eʸ`. Results are undefined if `x <= 0`.\n  vec2 log(vec2 x);\n  // Returns the natural logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = eʸ`. Results are undefined if `x <= 0`.\n  vec3 log(vec3 x);\n  // Returns the natural logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = eʸ`. Results are undefined if `x <= 0`.\n  vec4 log(vec4 x);\n\n  // Returns 2 raised to the `x` power, i.e., `2ˣ`.\n  float exp2(float x);\n  // Returns 2 raised to the `x` power, i.e., `2ˣ`.\n  vec2 exp2(vec2 x);\n  // Returns 2 raised to the `x` power, i.e., `2ˣ`.\n  vec3 exp2(vec3 x);\n  // Returns 2 raised to the `x` power, i.e., `2ˣ`.\n  vec4 exp2(vec4 x);\n\n  // Returns the base 2 logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = 2ʸ`. Results are undefined if `x <= 0`.\n  float log2(float x);\n  // Returns the base 2 logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = 2ʸ`. Results are undefined if `x <= 0`.\n  vec2 log2(vec2 x);\n  // Returns the base 2 logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = 2ʸ`. Results are undefined if `x <= 0`.\n  vec3 log2(vec3 x);\n  // Returns the base 2 logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = 2ʸ`. Results are undefined if `x <= 0`.\n  vec4 log2(vec4 x);\n\n  // Returns `√x`. Results are undefined if `x < 0`.\n  float sqrt(float x);\n  // Returns `√x`. Results are undefined if `x < 0`.\n  vec2 sqrt(vec2 x);\n  // Returns `√x`. Results are undefined if `x < 0`.\n  vec3 sqrt(vec3 x);\n  // Returns `√x`. Results are undefined if `x < 0`.\n  vec4 sqrt(vec4 x);\n\n  // Returns `1 / √x`. Results are undefined if `x <= 0`.\n  float inversesqrt(float x);\n  // Returns `1 / √x`. Results are undefined if `x <= 0`.\n  vec2 inversesqrt(vec2 x);\n  // Returns `1 / √x`. Results are undefined if `x <= 0`.\n  vec3 inversesqrt(vec3 x);\n  // Returns `1 / √x`. Results are undefined if `x <= 0`.\n  vec4 inversesqrt(vec4 x);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Common Functions\n\n  // Returns `x` if `x >= 0`, otherwise it returns `-x`.\n  float abs(float x);\n  // Returns `x` if `x >= 0`, otherwise it returns `-x`.\n  vec2 abs(vec2 x);\n  // Returns `x` if `x >= 0`, otherwise it returns `-x`.\n  vec3 abs(vec3 x);\n  // Returns `x` if `x >= 0`, otherwise it returns `-x`.\n  vec4 abs(vec4 x);\n\n  // Returns `1.0` if `x > 0`, `0.0` if `x = 0`, or `-1.0` if `x < 0`\n  float sign(float x);\n  // Returns `1.0` if `x > 0`, `0.0` if `x = 0`, or `-1.0` if `x < 0`\n  vec2 sign(vec2 x);\n  // Returns `1.0` if `x > 0`, `0.0` if `x = 0`, or `-1.0` if `x < 0`\n  vec3 sign(vec3 x);\n  // Returns `1.0` if `x > 0`, `0.0` if `x = 0`, or `-1.0` if `x < 0`\n  vec4 sign(vec4 x);\n\n  // Returns a value equal to the nearest integer that is less than or equal to `x`\n  float floor(float x);\n  // Returns a value equal to the nearest integer that is less than or equal to `x`\n  vec2 floor(vec2 x);\n  // Returns a value equal to the nearest integer that is less than or equal to `x`\n  vec3 floor(vec3 x);\n  // Returns a value equal to the nearest integer that is less than or equal to `x`\n  vec4 floor(vec4 x);\n\n  // Returns a value equal to the nearest integer that is greater than or equal to `x`\n  float ceil(float x);\n  // Returns a value equal to the nearest integer that is greater than or equal to `x`\n  vec2 ceil(vec2 x);\n  // Returns a value equal to the nearest integer that is greater than or equal to `x`\n  vec3 ceil(vec3 x);\n  // Returns a value equal to the nearest integer that is greater than or equal to `x`\n  vec4 ceil(vec4 x);\n\n  // Returns `x - floor(x)`\n  float fract(float x);\n  // Returns `x - floor(x)`\n  vec2 fract(vec2 x);\n  // Returns `x - floor(x)`\n  vec3 fract(vec3 x);\n  // Returns `x - floor(x)`\n  vec4 fract(vec4 x);\n\n  // Modulus (modulo). Returns `x - y * floor(x/y)`\n  float mod(float x, float y);\n  // Modulus (modulo). Returns `x - y * floor(x/y)`\n  vec2 mod(vec2 x, float y);\n  // Modulus (modulo). Returns `x - y * floor(x/y)`\n  vec3 mod(vec3 x, float y);\n  // Modulus (modulo). Returns `x - y * floor(x/y)`\n  vec4 mod(vec4 x, float y);\n\n  // Modulus. Returns `x - y * floor(x/y)`\n  vec2 mod(vec2 x, vec2 y);\n  // Modulus. Returns `x - y * floor(x/y)`\n  vec3 mod(vec3 x, vec3 y);\n  // Modulus. Returns `x - y * floor(x/y)`\n  vec4 mod(vec4 x, vec4 y);\n\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  float min(float x, float y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec2 min(vec2 x, float y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec2 min(vec2 x, vec2 y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec3 min(vec3 x, float y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec3 min(vec3 x, vec3 y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec4 min(vec4 x, float y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec4 min(vec4 x, vec4 y);\n\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  float max(float x, float y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec2 max(vec2 x, float y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec2 max(vec2 x, vec2 y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec3 max(vec3 x, float y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec3 max(vec3 x, vec3 y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec4 max(vec4 x, float y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec4 max(vec4 x, vec4 y);\n\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  float clamp(float x, float minVal, float maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec2 clamp(vec2 x, float minVal, float maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec2 clamp(vec2 x, vec2 minVal, vec2 maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec3 clamp(vec3 x, float minVal, float maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec3 clamp(vec3 x, vec3 minVal, vec3 maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec4 clamp(vec4 x, float minVal, float maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec4 clamp(vec4 x, vec4 minVal, vec4 maxVal);\n\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  float mix(float x, float y, float a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec2 mix(vec2 x, vec2 y, float a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec2 mix(vec2 x, vec2 y, vec2 a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec3 mix(vec3 x, vec3 y, float a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec3 mix(vec3 x, vec3 y, vec3 a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec4 mix(vec4 x, vec4 y, float a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec4 mix(vec4 x, vec4 y, vec4 a);\n\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  float step(float edge, float x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec2 step(float edge, vec2 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec2 step(vec2 edge, vec2 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec3 step(float edge, vec3 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec3 step(vec3 edge, vec3 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec4 step(float edge, vec4 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec4 step(vec4 edge, vec4 x);\n\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  float smoothstep(float edge0, float edge1, float x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec2 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec2 smoothstep(float edge0, float edge1, vec2 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec2 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec3 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec3 smoothstep(float edge0, float edge1, vec3 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec3 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec4 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec4 smoothstep(float edge0, float edge1, vec4 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec4 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Geometric Functions\n\n  // Returns the length of vector `x`, i.e. `√x²`\n  float length(float x);\n  // Returns the length of vector `x`, i.e. `√x[0]² + x[1]²`\n  float length(vec2 x);\n  // Returns the length of vector `x`, i.e. `√x[0]² + x[1]² + x[2]²`\n  float length(vec3 x);\n  // Returns the length of vector `x`, i.e. `√x[0]² + x[1]² + x[2]² + x[3]²`\n  float length(vec4 x);\n\n  // Returns the distance between `p0` and `p1`, i.e. `length(p0 - p1)`\n  float distance(float p0, float p1);\n  // Returns the distance between `p0` and `p1`, i.e. `length(p0 - p1)`\n  float distance(vec2 p0, vec2 p1);\n  // Returns the distance between `p0` and `p1`, i.e. `length(p0 - p1)`\n  float distance(vec3 p0, vec3 p1);\n  // Returns the distance between `p0` and `p1`, i.e. `length(p0 - p1)`\n  float distance(vec4 p0, vec4 p1);\n\n  // Returns the dot product of `x` and `y`, i.e. `x*y`\n  float dot(float x, float y);\n  // Returns the dot product of `x` and `y`, i.e. `x[0]*y[0] + x[1]*y[1]`\n  float dot(vec2 x, vec2 y);\n  // Returns the dot product of `x` and `y`, i.e. `x[0]*y[0] + x[1]*y[1] + x[2]*y[2]`\n  float dot(vec3 x, vec3 y);\n  // Returns the dot product of `x` and `y`, i.e. `x[0]*y[0] + x[1]*y[1] + x[2]*y[2] + x[3]*y[3]`\n  float dot(vec4 x, vec4 y);\n\n  // Returns the cross product of `x` and `y`, i.e.\n  //\n  // ```glslx\n  // vec3(\n  //   x[1]*y[2] - y[1]*x[2],\n  //   x[2]*y[0] - y[2]*x[0],\n  //   x[0]*y[1] - y[0]*x[1])\n  // ```\n  vec3 cross(vec3 x, vec3 y);\n\n  // Returns a vector in the same direction as `x` but with a length of 1.\n  float normalize(float x);\n  // Returns a vector in the same direction as `x` but with a length of 1.\n  vec2 normalize(vec2 x);\n  // Returns a vector in the same direction as `x` but with a length of 1.\n  vec3 normalize(vec3 x);\n  // Returns a vector in the same direction as `x` but with a length of 1.\n  vec4 normalize(vec4 x);\n\n  // If `dot(Nref, I) < 0` return `N`, otherwise return `-N`\n  float faceforward(float N, float I, float Nref);\n  // If `dot(Nref, I) < 0` return `N`, otherwise return `-N`\n  vec2 faceforward(vec2 N, vec2 I, vec2 Nref);\n  // If `dot(Nref, I) < 0` return `N`, otherwise return `-N`\n  vec3 faceforward(vec3 N, vec3 I, vec3 Nref);\n  // If `dot(Nref, I) < 0` return `N`, otherwise return `-N`\n  vec4 faceforward(vec4 N, vec4 I, vec4 Nref);\n\n  // For the incident vector `I` and surface orientation `N`, returns the reflection direction: `I - 2 * dot(N, I) * N`.\n  // `N` must already be normalized in order to achieve the desired result.\n  float reflect(float I, float N);\n  // For the incident vector `I` and surface orientation `N`, returns the reflection direction: `I - 2 * dot(N, I) * N`.\n  // `N` must already be normalized in order to achieve the desired result.\n  vec2 reflect(vec2 I, vec2 N);\n  // For the incident vector `I` and surface orientation `N`, returns the reflection direction: `I - 2 * dot(N, I) * N`.\n  // `N` must already be normalized in order to achieve the desired result.\n  vec3 reflect(vec3 I, vec3 N);\n  // For the incident vector `I` and surface orientation `N`, returns the reflection direction: `I - 2 * dot(N, I) * N`.\n  // `N` must already be normalized in order to achieve the desired result.\n  vec4 reflect(vec4 I, vec4 N);\n\n  // For the incident vector `I` and surface normal `N`, and the ratio of indices of refraction `eta`, return the refraction vector.\n  // The result is computed by:\n  //\n  // ```glslx\n  // float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n  // if (k < 0.0) return float(0.0);\n  // else return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n  // ```\n  //\n  // The input parameters for the incident vector `I` and the surface normal `N`.\n  float refract(float I, float N, float eta);\n  // For the incident vector `I` and surface normal `N`, and the ratio of indices of refraction `eta`, return the refraction vector.\n  // The result is computed by:\n  //\n  // ```glslx\n  // float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n  // if (k < 0.0) return vec2(0.0);\n  // else return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n  // ```\n  //\n  // The input parameters for the incident vector `I` and the surface normal `N`.\n  vec2 refract(vec2 I, vec2 N, float eta);\n  // For the incident vector `I` and surface normal `N`, and the ratio of indices of refraction `eta`, return the refraction vector.\n  // The result is computed by:\n  //\n  // ```glslx\n  // float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n  // if (k < 0.0) return vec3(0.0);\n  // else return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n  // ```\n  //\n  // The input parameters for the incident vector `I` and the surface normal `N`.\n  vec3 refract(vec3 I, vec3 N, float eta);\n  // For the incident vector `I` and surface normal `N`, and the ratio of indices of refraction `eta`, return the refraction vector.\n  // The result is computed by:\n  //\n  // ```glslx\n  // float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n  // if (k < 0.0) return vec4(0.0);\n  // else return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n  // ```\n  //\n  // The input parameters for the incident vector `I` and the surface normal `N`.\n  vec4 refract(vec4 I, vec4 N, float eta);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Matrix Functions\n\n  // Multiply matrix `x` by matrix `y` component-wise, i.e., `result[i][j]` is the scalar product of `x[i][j]` and `y[i][j]`.\n  // Note: to get linear algebraic matrix multiplication, use the multiply operator (`*`).\n  mat2 matrixCompMult(mat2 x, mat2 y);\n  // Multiply matrix `x` by matrix `y` component-wise, i.e., `result[i][j]` is the scalar product of `x[i][j]` and `y[i][j]`.\n  // Note: to get linear algebraic matrix multiplication, use the multiply operator (`*`).\n  mat3 matrixCompMult(mat3 x, mat3 y);\n  // Multiply matrix `x` by matrix `y` component-wise, i.e., `result[i][j]` is the scalar product of `x[i][j]` and `y[i][j]`.\n  // Note: to get linear algebraic matrix multiplication, use the multiply operator (`*`).\n  mat4 matrixCompMult(mat4 x, mat4 y);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Vector Relational Functions\n\n  // Returns the component-wise compare of `x < y`.\n  bvec2 lessThan(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec2 lessThan(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec3 lessThan(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec3 lessThan(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec4 lessThan(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec4 lessThan(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x <= y`.\n  bvec2 lessThanEqual(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec2 lessThanEqual(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec3 lessThanEqual(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec3 lessThanEqual(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec4 lessThanEqual(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec4 lessThanEqual(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x > y`.\n  bvec2 greaterThan(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec2 greaterThan(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec3 greaterThan(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec3 greaterThan(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec4 greaterThan(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec4 greaterThan(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x >= y`.\n  bvec2 greaterThanEqual(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec2 greaterThanEqual(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec3 greaterThanEqual(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec3 greaterThanEqual(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec4 greaterThanEqual(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec4 greaterThanEqual(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x == y`.\n  bvec2 equal(bvec2 x, bvec2 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec2 equal(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec2 equal(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec3 equal(bvec3 x, bvec3 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec3 equal(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec3 equal(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec4 equal(bvec4 x, bvec4 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec4 equal(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec4 equal(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x != y`.\n  bvec2 notEqual(bvec2 x, bvec2 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec2 notEqual(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec2 notEqual(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec3 notEqual(bvec3 x, bvec3 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec3 notEqual(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec3 notEqual(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec4 notEqual(bvec4 x, bvec4 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec4 notEqual(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec4 notEqual(vec4 x, vec4 y);\n\n  // Returns true if any component of `x` is `true`.\n  bool any(bvec2 x);\n  // Returns true if any component of `x` is `true`.\n  bool any(bvec3 x);\n  // Returns true if any component of `x` is `true`.\n  bool any(bvec4 x);\n\n  // Returns true only if all components of `x` are `true`.\n  bool all(bvec2 x);\n  // Returns true only if all components of `x` are `true`.\n  bool all(bvec3 x);\n  // Returns true only if all components of `x` are `true`.\n  bool all(bvec4 x);\n\n  // Returns the component-wise logical complement of `x`.\n  bvec2 not(bvec2 x);\n  // Returns the component-wise logical complement of `x`.\n  bvec3 not(bvec3 x);\n  // Returns the component-wise logical complement of `x`.\n  bvec4 not(bvec4 x);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Texture Lookup Functions\n\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  vec4 texture2D(sampler2D sampler, vec2 coord);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  vec4 texture2D(sampler2D sampler, vec2 coord, float bias);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`.\n  vec4 texture2DProj(sampler2D sampler, vec3 coord);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`.\n  vec4 texture2DProj(sampler2D sampler, vec3 coord, float bias);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`.\n  vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`. The third component of `coord` is ignored.\n  vec4 texture2DProj(sampler2D sampler, vec4 coord);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`. The third component of `coord` is ignored.\n  vec4 texture2DProj(sampler2D sampler, vec4 coord, float bias);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`. The third component of `coord` is ignored.\n  vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod);\n\n  // Use the texture coordinate `coord` to do a texture lookup in the cube map texture currently bound to `sampler`.\n  // The direction of `coord` is used to select which face to do a 2-dimensional texture lookup in.\n  vec4 textureCube(samplerCube sampler, vec3 coord);\n  // Use the texture coordinate `coord` to do a texture lookup in the cube map texture currently bound to `sampler`.\n  // The direction of `coord` is used to select which face to do a 2-dimensional texture lookup in.\n  vec4 textureCube(samplerCube sampler, vec3 coord, float bias);\n  // Use the texture coordinate `coord` to do a texture lookup in the cube map texture currently bound to `sampler`.\n  // The direction of `coord` is used to select which face to do a 2-dimensional texture lookup in.\n  vec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod);\n\n  #extension GL_OES_standard_derivatives {\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `x` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    float dFdx(float v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `x` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec2 dFdx(vec2 v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `x` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec3 dFdx(vec3 v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `x` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec4 dFdx(vec4 v);\n\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `y` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdy(dFdy(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    float dFdy(float v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `y` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdy(dFdy(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec2 dFdy(vec2 v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `y` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdy(dFdy(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec3 dFdy(vec3 v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `y` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdy(dFdy(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec4 dFdy(vec4 v);\n\n    // Returns the sum of the absolute derivative in `x` and `y` using local differencing for the input argument `p`, i.e. `abs(dFdx(p)) + abs(dFdy(p))`\n    float fwidth(float v);\n    // Returns the sum of the absolute derivative in `x` and `y` using local differencing for the input argument `p`, i.e. `abs(dFdx(p)) + abs(dFdy(p))`\n    vec2 fwidth(vec2 v);\n    // Returns the sum of the absolute derivative in `x` and `y` using local differencing for the input argument `p`, i.e. `abs(dFdx(p)) + abs(dFdy(p))`\n    vec3 fwidth(vec3 v);\n    // Returns the sum of the absolute derivative in `x` and `y` using local differencing for the input argument `p`, i.e. `abs(dFdx(p)) + abs(dFdy(p))`\n    vec4 fwidth(vec4 v);\n  }\n\n  #extension GL_EXT_frag_depth {\n    // Available only in the fragment language, `gl_FragDepthEXT` is an output variable that is used to establish the depth value for the current fragment.\n    // If depth buffering is enabled and no shader writes to `gl_FragDepthEXT`, then the fixed function value for depth will be used (this value is contained\n    // in the `z` component of `gl_FragCoord`) otherwise, the value written to `gl_FragDepthEXT` is used.\n    //\n    // If a shader statically assigns to `gl_FragDepthEXT`, then the value of the fragment's depth may be undefined for executions of the shader that take\n    // that path. That is, if the set of linked fragment shaders statically contain a write to `gl_FragDepthEXT`, then it is responsible for always writing it.\n    float gl_FragDepthEXT;\n  }\n\n  #extension GL_EXT_shader_texture_lod {\n    vec4 texture2DGradEXT(sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\n    vec4 texture2DLodEXT(sampler2D sampler, vec2 coord, float lod);\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec3 coord, float lod);\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec4 coord, float lod);\n    vec4 textureCubeGradEXT(samplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\n    vec4 textureCubeLodEXT(samplerCube sampler, vec3 coord, float lod);\n  }\n}\n"));
for(var Q=0,ia=b.length;Q<ia;Q=Q+1|0){var d=b[Q];d.c=Jc(a,d,0)}for(var e=new Jh(0),f=new Vh(1,null),h=new uh(c.e),m=new Th(a,h),M=0,ha=b.length;M<ha;M=M+1|0){var l=b[M];jd(a,l.c,e,h,f,m)}if(nd(m,e),a.c)return null;for(var g=[],i=[],ca=0,ua=$e(f),aa=ua.length;ca<aa;ca=ca+1|0){for(var o=ua[ca],k=new Jh(0),r=new Vh(1,null),s=new uh(c.e),w=new Ih,p=new Th(w,s),Z=0,$=b.length;Z<$;Z=Z+1|0){var C=b[Z];jd(w,C.c,k,s,r,p)}nd(p,k),af(r,o),zg(k,s,c),i.push(k),g.push(o.c)}for(var B=[],U=og(new Rh(c.c),i),F=0,ka=g.length;F<ka;F=F+1|0)B.push(new Xh(g[F],new yh(i[F],c).a));return new vh(B,U)}function $e(a){for(var b=[],d=0,e=Array.from(a.c.values()),f=e.length;d<f;d=d+1|0){var c=e[d];c instanceof oc&&c.e&1024&&b.push(c)}return b}function af(a,b){for(var e=0,f=Array.from(a.c.values()),h=f.length;e<h;e=e+1|0){var c=f[e];if(c.a^b.a)c.e&=-1025;else{c.c='main';var d=c.s;d&&(d.c=c.c)}}}function bf(c,a){var b=a.l;c.b.push(c.b.length==0||Rc(c.b)),b&&ce(b.b)&&c.a.push(!1)}function cf(d,a){var b=a.l,c=d.b.pop();c&&(a.r=!0),b&&ce(b.b)&&!d.a.pop()&&(b.b==19&&Ra(b.g)||b.b==7&&Ra(b.i)||b.b==10&&(!Ca(b)||Ra(Ca(b))))&&hb(d.b,
!1)}function Hd(e,a){if(Rc(e.b))switch(a.b){case 4:e.a.length&&hb(e.a,!0),hb(e.b,!1);break;case 15:case 6:case 5:hb(e.b,!1);break;case 12:var b=a.g,c=a.g.k,d=a.g.k.k;Ra(b)?c.r||hb(e.b,!1):Cb(b)&&d?d.r||hb(e.b,!1):c&&d&&!c.r&&!d.r&&hb(e.b,!1);break}}function df(a,b){return Id(a)||Id(b)||a.b!=b.b&&(a.b==14||b.b==14||a.b==9||b.b==9)}function Id(a){return a.b==11&&a.e.k!=null}function Jd(a,b){var c=a.toString(),d=a.toExponential();d.length<c.length&&(c=d);var e=c.indexOf('e'),f='';return ~e&&(f=c.slice(e),c=c.slice(0,e)),c=(+(+c).toFixed(6)).toString(),f==''&&c.indexOf('.')==-1&&(c+=b^1?'.0':'.'),b==1&&c.startsWith('0.')&&c!='0.'&&(c=c.slice(1)),b==1&&c.startsWith('-0.')&&c!='-0.'&&(c='-'+c.slice(2)),c+f}function ef(b,a){switch(a.b){case 11:case 16:return (a.e.e&2048)!=0;case 17:return ((a.h|0)&2048)!=0}return!1}function Tc(a){a.e||(a.b+='  ')}function Uc(a){a.e||(a.b=a.b.slice(2))}function Xa(i,a){switch(a.b){case 3:if(!a.g&&a.l)i.a+=';';else{i.a+='{'+i.c,Tc(i);for(var b=a.g;b;b=b.k)i.a+=i.b,Xa(i,b),i.a+=i.c;Uc(i),
i.a+=i.b+'}'}break;case 4:i.a+='break;';break;case 5:i.a+='continue;';break;case 6:i.a+='discard;';break;case 7:i.a+='do',Zb(i,a.g,0),i.a+=i.c+i.b+'while'+i.d+'(',I(i,a.i,0),i.a+=');';break;case 8:I(i,a.g,0),i.a+=';';break;case 9:Kd(i),i.a+='#extension '+a.m+i.d+':'+i.d;switch(a.h|0){case 1:i.a+='disable';break;case 2:i.a+='enable';break;case 3:i.a+='require';break;case 4:i.a+='warn';break}Ld(i);break;case 10:i.a+='for'+i.d+'(',kb(a)?kb(a).b^17?(I(i,kb(a),0),i.a+=';'):Xa(i,kb(a)):i.a+=';',Ca(a)&&(i.a+=i.d,I(i,Ca(a),0)),i.a+=';',Ec(a)&&(i.a+=i.d,I(i,Ec(a),0)),i.a+=')',Zb(i,a.i,1);break;case 11:var c=a.e;i.a+=$a(c.e),I(i,c.o,0),i.a+=' ',i.a+=c.c,i.a+='(';for(var o=0,k=c.i,r=k.length;o<r;o=o+1|0){var d=k[o];d!=c.i[0]&&(i.a+=','+i.d),i.a+=$a(d.e),I(i,d.p,0),i.a+=' ',Vc(i,d)}i.a+=')',c.k?(i.a+=i.d,Xa(i,c.k)):i.a+=';';break;case 12:i.a+='if'+i.d+'(',I(i,a.g,0),i.a+=')',Zb(i,a.g.k,1),a.g.k.k&&(i.a+=i.c+i.b+'else',a.g.k.k.b^12?Zb(i,a.g.k.k,0):(i.a+=' ',Xa(i,a.g.k.k)));break;case 14:i.a+='precision ',i.a+=$a(a.h|0),I(i,
a.g,0),i.a+=';';break;case 15:var e=a.g;i.a+='return',e&&(Rf(e.b)||(i.a+=' '),I(i,e,0)),i.a+=';';break;case 16:var f=a.e;i.a+=$a(f.e),i.a+='struct '+f.c+i.d+'{'+i.c,Tc(i);for(var h=a.g.g;h;h=h.k)i.a+=i.b,Xa(i,h),i.a+=i.c;if(Uc(i),i.a+=i.b+'}',a.g.k)for(var m=a.g.k.g.k;m;m=m.k)i.a+=m.o.o?','+i.d:i.d,Vc(i,m.e);i.a+=';';break;case 17:i.a+=$a(a.h|0),I(i,a.g,0);for(var l=a.g.k;l;l=l.k){var g=l.e;i.a+=l.o.o?','+i.d:' ',Vc(i,g)}i.a+=';';break;case 18:Kd(i),i.a+='#version '+(a.h|0),Ld(i);break;case 19:i.a+='while'+i.d+'(',I(i,a.g,0),i.a+=')',Zb(i,a.i,1);break;default:i.a+=Sg[a.b];break}}function Kd(a){a.a!=''&&!a.a.endsWith('\n')&&(a.a+='\n')}function Ld(a){a.e&&(a.a+='\n')}function Zb(c,a,b){a.b^3?(c.a+=c.e&&!b?' ':c.c,Tc(c),c.a+=c.b,Xa(c,a),Uc(c)):(c.a+=c.d,Xa(c,a))}function Md(c,a){for(var b=a;b;b=b.k)b!=a&&(c.a+=','+c.d),I(c,b,1)}function Vc(b,a){b.a+=a.c,a.B&&(b.a+='[',I(b,a.B,0),b.a+=']'),N(a)&&(b.a+=b.d+'='+b.d,I(b,N(a),1))}function I(c,a,b){switch(a.b){case 20:I(c,a.g,15),c.a+='(',Md(c,a.g.k),c.a+=')';break;case 21:
I(c,a.g,16),c.a+='.',c.a+=a.e?a.e.c:a.m;break;case 22:2<b&&(c.a+='('),I(c,a.g,3),c.a+=c.d+'?'+c.d,I(c,a.g.k,2),c.a+=c.d+':'+c.d,I(c,a.i,2),2<b&&(c.a+=')');break;case 23:c.a+=a.e.c;break;case 25:0<b&&(c.a+='('),Md(c,a.g),0<b&&(c.a+=')');break;case 26:c.a+=He(a.f).a.c;break;case 28:c.a+=(!!a.h).toString();break;case 29:c.a+=Jd(a.h,c.e?1:0);break;case 30:c.a+=(a.h|0).toString();break;case 43:I(c,a.g,16),c.a+='[',I(c,a.i,0),c.a+=']';break;case 31:_b(c,'-',a,b);break;case 32:_b(c,'!',a,b);break;case 33:_b(c,'+',a,b);break;case 34:_b(c,'--',a,b);break;case 35:_b(c,'++',a,b);break;case 36:Nd(c,'--',a,b);break;case 37:Nd(c,'++',a,b);break;case 38:V(c,'+',a,b,12);break;case 39:V(c,'/',a,b,13);break;case 40:V(c,'==',a,b,10);break;case 41:V(c,'>',a,b,10);break;case 42:V(c,'>=',a,b,10);break;case 44:V(c,'<',a,b,10);break;case 45:V(c,'<=',a,b,10);break;case 46:V(c,'&&',a,b,5);break;case 47:V(c,'||',a,b,3);break;case 48:V(c,'^^',a,b,4);break;case 49:V(c,'*',a,b,13);break;case 50:V(c,'!=',a,b,10);break;case 51:V(c,'-',a,b,12);
break;case 52:V(c,'=',a,b,2);break;case 53:V(c,'+=',a,b,2);break;case 54:V(c,'/=',a,b,2);break;case 55:V(c,'*=',a,b,2);break;case 56:V(c,'-=',a,b,2);break;default:c.a+=Sg[a.b];break}}function _b(f,a,b,c){var d=b.g,e=d.b;f.a+=a,(a.charCodeAt(0)==45&&(e==31||e==34||Wf(d))||a.charCodeAt(0)==43&&(e==33||e==35))&&(f.a+=' '),I(f,d,14)}function Nd(d,a,b,c){I(d,b.g,15),d.a+=a}function V(f,a,b,c,d){var e=Bc(b.b);d<c&&(f.a+='('),I(f,b.g,d+(e|0)|0),f.a+=f.d+a+f.d,I(f,b.i,d+(!e|0)|0),d<c&&(f.a+=')')}function G(a){if(a.f==K)return null;switch(a.b){case 30:case 29:case 28:return Ya(a);case 23:return ff(a);case 25:return gf(a);case 22:return hf(a);case 21:return jf(a);case 43:return kf(a);case 20:return lf(a);case 31:return Td(a,function(b){return-b},function(c){return -c|0});case 32:return sf(a,function(d){return!d});case 33:return Td(a,function(e){return+e},function(f){return+f});case 38:return Xc(a,function(h,m){return h+m},function(l,g){return l+g|0});case 51:return Xc(a,function(i,o){return i-o},function(k,r){return k-r|0});
case 49:return mf(a);case 39:return Xc(a,function(s,w){return w!=0?s/w:0},function(p,C){return C?p/C|0:0});case 40:case 50:return pf(a);case 46:return Wc(a,function(B,U){return B&&U});case 47:return Wc(a,function(F,Q){return F||Q});case 48:return Wc(a,function(ia,M){return ia!=M});case 41:return tc(a,function(ha,Z){return ha>Z});case 42:return tc(a,function($,ca){return $>=ca});case 44:return tc(a,function(ua,aa){return ua<aa});case 45:return tc(a,function(ka,va){return ka<=va})}return null}function ff(a){var b=a.e;if(b&&b.e&2){if(b.h)return Ya(b.h);if(b.w)return t(new Jh(27),a.f)}return null}function gf(a){for(var b=a.g;b;b=b.k){var c=G(b);if(!c||b==a.i)return c}return null}function hf(a){var b=G(a.g),c=G(a.g.k),d=G(a.i);return b&&b.b==28&&c&&d?!b.h?d:c:null}function jf(a){var b=G(a.g);if(b&&b.b==20){var c=b.f,d=a.m;if(wd(c))for(var e=d.length,f=Ea(c),s=0,w=rd(f),p=w.length;s<p;s=s+1|0){var h=w[s];if(~h.indexOf(d[0])){if(e==1)return q(bc(b,1+h.indexOf(d)|0));for(var m=sd(fa(c),e),l=sa(m),g=0;g<e;g=g+1|0)n(l,Ya(bc(b,
1+h.indexOf(d[g])|0)));return l}}else if(c.a&&c.a instanceof Tb)for(var i=c.a,o=i.g,k=0,C=o.length;k<C;k=k+1|0){var r=o[k];if(r.c==d)return q(bc(b,1+k|0))}}return null}function kf(a){var b=G(a.g),c=G(a.i);if(b&&b.b==20&&c&&c.b==30){var d=b.f;if(wd(d)){var e=Sa(d),f=c.h|0;if(-1<f&&f<e)return q(bc(b,f+1|0))}else if(ab(d)){var h=Sa(d),m=c.h|0;if(-1<m&&m<h){for(var l=vd(d),g=sa(l),i=bc(b,qh(m,h)),o=0;o<h;o=o+1|0)n(g,q(i.k));return g}}}return null}function lf(a){var b=a.g;if(b.b^26)return null;for(var c=b.f,d=fa(c),e=0,f=[],h=0,m=b.k;m;m=m.k){var l=G(m);if(!l)return null;if(l.b==20&&d&&fa(l.g.f))for(var g=l.g.k;g;g=g.k){var i=Od(d,g);if(!i)return null;f.push(i)}else{if(d&&(l=Od(d,l),!l))return null;f.push(l)}ab(l.f)&&(e=Sa(l.f)),h=h+1|0}return ab(c)&&e&&h^1?null:fa(c)?nf(f,c,ab(c)?e:0):c.a&&c.a instanceof Tb?of(f,c):null}function Bb(a){for(var b=[],c=a.g.k;c;c=c.k)b.push(c.h);return b}function mf(a){var va,b=G(a.g),c=G(a.i),d=b&&b.f,e=c&&c.f;if(b&&c){if(d==Fa&&e==ob||d==Ga&&e==pb||d==Ha&&e==qb){for(var f=Sa(d),h=sa(d),m=Bb(b),l=Bb(c),g=0;g<f;g=g+1|0){
for(var i=0,o=0;o<f;o=o+1|0)i+=m[o]*l[o+qh(g,f)|0];n(h,t(ma(new Jh(29),i),da))}return h}if(d==ob&&e==Fa||d==pb&&e==Ga||d==qb&&e==Ha){for(var k=Sa(d),r=sa(e),s=Bb(b),w=Bb(c),p=0;p<k;p=p+1|0){for(var C=0,B=0;B<k;B=B+1|0)C+=s[p+qh(B,k)|0]*w[B];n(r,t(ma(new Jh(29),C),da))}return r}if(ab(d)&&e==d){for(var U=Sa(d),F=sa(d),Q=Bb(b),ia=Bb(c),M=0;M<U;M=M+1|0)for(var ha=0;ha<U;ha=ha+1|0){for(var Z=0,$=0;$<U;$=$+1|0)Z+=Q[ha+qh($,U)|0]*ia[$+qh(M,U)|0];n(F,t(ma(new Jh(29),Z),da))}return F}return (va=Rd(b,c,function(ca,ua){return ca*ua}))||Sd(b,c,function(aa,ka){return qh(aa,ka)})}return null}function Od(a,b){var c=0;switch(b.b){case 28:c=+!!b.h;break;case 30:c=b.h|0;break;case 29:c=b.h;break;default:return null}switch(a){case Y:return t(Ba(new Jh(28),!!c),Y);case ga:return t(_(new Jh(30),c|0),ga);case da:return t(ma(new Jh(29),c),da)}return null}function nf(a,b,c){var d=Ea(b),e=fa(b),f=sa(b);if(a.length^1){if(c){for(var o=Sa(b),k=0;k<o;k=k+1|0)for(var r=0;r<o;r=r+1|0)n(f,r<c&&k<c?a[r+qh(k,c)|0]:t(ma(new Jh(29),r^k?0:1),da))}
else{if(a.length<d)return null;for(var s=0;s<d;s=s+1|0){var w=a[s];if(w.f!=e)return null;n(f,w)}}}else{var h=a[0];if(h.f!=e)return null;for(var m=ab(b),l=Sa(b),g=0;g<d;g=g+1|0){var i=m&&(g%(l+1|0)|0)!=0;n(f,i?t(ma(new Jh(29),0),da):Ya(h))}}return vd(b)?f:q(f.i)}function of(a,b){var c=b.a.g,d=sa(b);if(a.length^c.length)return null;for(var e=0,f=a.length;e<f;e=e+1|0){if(a[e].f!=c[e].p.f)return null;n(d,a[e])}return d}function pf(a){var b=G(a.g),c=G(a.i);if(b&&c){var d=oa(b,c);return t(Ba(new Jh(28),a.b^40?!d:d),Y)}return null}function Pd(a,b,c,d){if(a.b==20&&a.g.b==26&&fa(a.g.f)==b){for(var e=sa(a.g.f),f=a.g.k;f;f=f.k){var h=G(f);if(!h||h.b^c)return null;n(e,d(h))}return e}return null}function qf(a,b){return a.b^29?Pd(a,da,29,function(c){return t(ma(new Jh(29),b(c.h)),da)}):t(ma(new Jh(29),b(a.h)),da)}function rf(a,b){return a.b^30?Pd(a,ga,30,function(c){return t(_(new Jh(30),b(c.h|0)),ga)}):t(_(new Jh(30),b(a.h|0)),ga)}function Qd(a,b,c,d,e){var f=a.b==20&&a.g.b==26&&fa(a.g.f)==c,h=b.b==20&&b.g.b==26&&fa(b.g.f)==c;
if(f&&h&&b.f==a.f){for(var m=sa(a.f),l=a.g.k,g=b.g.k;l&&g;){var i=G(l),o=G(g);if(!i||i.b^d||!o||o.b^d)return null;n(m,e(i,o)),l=l.k,g=g.k}if(!l&&!g)return m}else if(f&&b.b==d){for(var k=sa(a.f),r=a.g.k;r;r=r.k){var s=G(r);if(!s||s.b^d)return null;n(k,e(s,b))}return k}else if(a.b==d&&h){for(var w=sa(b.f),p=b.g.k;p;p=p.k){var C=G(p);if(!C||C.b^d)return null;n(w,e(a,C))}return w}return null}function Rd(a,b,c){return a.b==29&&b.b==29?t(ma(new Jh(29),c(a.h,b.h)),da):Qd(a,b,da,29,function(d,e){return t(ma(new Jh(29),c(d.h,e.h)),da)})}function Sd(a,b,c){return a.b==30&&b.b==30?t(_(new Jh(30),c(a.h|0,b.h|0)),ga):Qd(a,b,ga,30,function(d,e){return t(_(new Jh(30),c(d.h|0,e.h|0)),ga)})}function sf(a,b){var c=G(a.g);return c&&c.b==28?t(Ba(new Jh(28),b(!!c.h)),Y):null}function Td(a,b,c){var e,d=G(a.g);return d&&((e=qf(d,b))||rf(d,c))}function Wc(a,b){var c=G(a.g),d=G(a.i);return c&&d&&c.b==28&&d.b==28?t(Ba(new Jh(28),b(!!c.h,!!d.h)),Y):null}function Xc(a,b,c){var f,d=G(a.g),e=G(a.i);return d&&e?(f=Rd(d,e,b))||Sd(d,e,c):null}
function tc(a,b){var c=G(a.g),d=G(a.i);if(c&&d){if(c.b==29&&d.b==29)return t(Ba(new Jh(28),b(c.h,d.h)),Y);if(c.b==30&&d.b==30)return t(Ba(new Jh(28),b(c.h|0,d.h|0)),Y)}return null}function Ud(a,b,c){for(var d=0,e=0,f=a.length;e<f;){var h=a.charCodeAt(e);e=e+1|0,uc(h)&&(d=d+1|0,h==13&&e<f&&a.charCodeAt(e)==10&&(e=e+1|0))}return d>2&&(d=2),Yb(c,d)}function tf(a,b,c){switch(c){case 48:switch(b){case 65:return!0;case 96:return!1}break;case 47:switch(b){case 62:return!0;case 96:return!1}break;case 65:if(b==65)return!0;break;case 62:if(b==62)return!0;break;case 85:if(ud(b)||b==88)return!1;break;case 84:if(ud(b)||b==88)return!1;break;case 81:case 90:case 89:case 88:case 82:return!1;case 87:if(b==83)return!1;break}switch(b){case 85:case 84:case 82:case 49:case 46:return!1;case 65:case 62:switch(a){case 99:case 85:case 84:case 81:case 80:case 90:case 49:case 46:case 32:case 12:return!1}if(Fg(a))return!1;break;case 48:case 47:if(c==96)return!1;break}return!0}function uc(a){return a==10||a==13}function uf(a){for(var b=0,c=a.length;b<c;b=b+1|0)if(uc(a.charCodeAt(b)))return!0;
return!1}function Vd(a){return a==32||a==9}function vc(a){for(var b=0,c=a.length;b<c;b=b+1|0)if(!Vd(a.charCodeAt(b)))return!1;return!0}function vf(a){for(var b=a.length;Vd(a.charCodeAt(b-1|0));)b=b-1|0;return a.slice(0,b)}function wf(a,b,c,d){for(var e=[],f=0,h=0,m=a.length;h<m;h=h+1|0){var l=a.charCodeAt(h);uc(l)&&(e.push(a.slice(f,h)),l==13&&(h+1|0)<m&&a.charCodeAt(h+1|0)==10&&(h=h+1|0),f=h+1|0)}e.push(a.slice(f));for(var g=b.length;g>0&&!uc(b.charCodeAt(g-1|0));)g=g-1|0;for(var i=b.slice(g),o=i,C=0,B=e.slice(1),U=B.length;C<U;C=C+1|0){var k=B[C];if(!vc(k)){for(var r=0,s=k.length;r<s&&r<o.length&&k.charCodeAt(r)==o.charCodeAt(r);)r=r+1|0;o=o.slice(0,r)}}for(var w='',F=0,Q=e.length;F<Q;F=F+1|0){var p=e[F];w==''?(vc(i)&&(w+=i.slice(o.length)),w+=p):(w+=d,vc(p)||(w+=c+p.slice(o.length)))}return w}function xf(a,b,c,d){var e=new Ih,f=new Xh('<stdin>',a),h=Jc(e,f,1);if(e.c)return a;var m='',l=99,g=99,i=0,o=0,k=!0,r=0,s=null,w=function(p){return!vc(a.slice(h[p-1|0].a.c,h[p].a.b))},C=function(B,U){switch(B){case 90:case 87:
return!0;case 4:case 9:case 10:case 11:case 12:case 15:case 17:case 32:case 43:return!U}return!1},F=null,Q=function(){for(var ia=1,M=r;M<h.length;M=M+1|0){switch(h[M].b){case 0:case 1:continue;case 83:ia=0;break}break}o=o+ia|0,F(),o=o-ia|0},ha=function(){var Z=1;return h[r].b==85&&w(r+1|0)&&(Z=0),o=o+Z|0,s(function($){return $==85})?(o=o-Z|0,!0):(o=o-Z|0,!1)};F=function(){for(;s(function(ca){return ca==0||ca==1}););switch(h[r].b){case 99:case 87:return!1;case 45:case 44:s(function(ua){return!0});break;case 17:s(function(aa){return!0}),ha()&&Q(),h[r].b^12||F();break;case 15:case 43:s(function(ka){return!0}),ha()&&Q();break;case 11:s(function(va){return!0}),Q(),s(function(Ua){return Ua==43})&&(ha(),s(function(la){return la==90}));break;case 12:if(s(function(rb){return!0}),h[r].b^17)Q();else{var La=w(r);La&&(o=o+1|0),s(function(Va){return!0}),ha()&&Q(),La&&(o=o-1|0)}break;case 83:case 90:s(function(wa){return!0});break;case 91:case 92:case 93:case 94:for(s(function(xa){return!0});s(function(eb){return!w(r)}););break;
default:var Ia=ud(h[r].b);if(s(function(Ja){return!0}),Ia&&s(function(fb){return fb==96})&&s(function(sb){return sb==85}))s(function(tb){return tb==83})||s(function(bb){return bb==90});else{for(var cb=!1;!cb&&w(r)&&(cb=!0,o=o+1|0),s(function(Ub){return!C(Ub,!1)}););s(function(ub){return ub==90}),cb&&(o=o-1|0)}break}return!0};var jc=function(){for(var Ka=[],Wa=r;Wa<h.length;){var pc=h[Wa].b;switch(pc){case 83:case 84:case 85:Ka.push(pc);break;case 87:if(!Ka.length)return Wa;if(Ka.pop()^83)return-1;break;case 88:if(!Ka.length||Ka.pop()^84)return-1;break;case 89:if(!Ka.length||Ka.pop()^85)return-1;break}Wa=Wa+1|0}return-1},kc=-1,Oc=function(){var Ob=jc(),Pb=Ob!=-1&&uf(a.slice(h[r-1|0].a.c,h[Ob].a.b));for(Pb&&(kc=r),o=o+1|0;F(););o=o-1|0,Pb&&(kc=r),s(function(lc){return lc==87})},Qb=function(){for(o=o+1|0;s(function(Rb){return Rb!=89}););o=o-1|0,s(function(yb){return yb==89})},Sb=function(){for(o=o+1|0;s(function(Pc){return Pc!=88}););o=o-1|0,s(function(Vb){return Vb==88})};for(s=function(qc){var Ta=h[r];if(!qc(Ta.b)||Ta.b==99)return!1;
var mc=kc^r?g^99?Ud(a.slice(i,Ta.a.b),b,c):'':'\n';r=r+1|0,m+=mc,mc!=''&&(k=!0),k?m+=Yb(b,o):tf(l,g,Ta.b)&&(m+=' ');var Ma=L(Ta.a);switch(Ta.b){case 0:Ma=vf(Ma);break;case 1:Ma=wf(Ma,a.slice(0,Ta.a.b),Yb(b,o),c);break}m+=Ma,l=g,g=Ta.b,i=Ta.a.c,k=!1;switch(Ta.b){case 83:Oc();break;case 85:Qb();break;case 84:Sb();break}return!0};F()||s(function(zb){return zb!=99}););var gb=Ud(a.slice(i),b,c);switch(d){case 0:gb!=''&&(m+=c);break;case 2:m!=''&&(m+=c);break}return m}function yf(a){return a.f!=null?new zh(D(a.h)+' '+a.f+';',''):a.d&&new zh(wc(a.d),xc(a.d.f))}function yc(b,a){return a.a==b.a&&gc(a,b.b)}function Yc(b,a){return yc(b,a.b)?(b.c=J(a),b.d=a,b.e=a.b,!0):!1}function Zc(b,a){return Yc(b,a)||Pa(b,a.p)||Pa(b,a.B)||Pa(b,N(a))}function zf(c,a){for(var d=0,e=a.i,f=e.length;d<f;d=d+1|0){var b=e[d];if(Zc(c,b))return!0}return Yc(c,a)||Pa(c,a.o)||Pa(c,a.k)}function Af(c,a){for(var d=0,e=a.g,f=e.length;d<f;d=d+1|0){var b=e[d];if(Zc(c,b))return!0}return Yc(c,a)}function Pa(c,a){var d;if(!a)return!1;for(var b=a.g;b;b=b.k)if(Pa(c,
b))return!0;switch(a.b){case 23:if(yc(c,a.c))return c.c=a.f,c.d=a.e,c.e=a.c,!0;break;case 26:if(yc(c,a.c))return c.c=a.f,c.d=((d=c.c).b?d.b:c.c).a,c.e=a.c,!0;break;case 21:if(yc(c,a.d))return c.c=a.f,wd(a.g.f)?(c.f=a.m,c.h=a.f):c.d=a.e,c.e=a.d,!0;break;case 2:return Zc(c,a.e);case 11:return zf(c,a.e);case 16:return Af(c,a.e)}return!1}function Xd(d,a){switch(a.b){case 16:case 11:Yd(d,a.e);break;case 17:for(var b=a.g.k;b;b=b.k)Yd(d,b.e);break;case 0:for(var c=a.g;c;c=c.k)Xd(d,c);break}}function Yd(b,a){a.b&&a.b.a==b.a&&b.b.push(a)}function Bf(m,a){var b=new Ah(m.a,m.b);if(Pa(b,a),m.d=b.d,m.d){jb(m,a);var c=null;m.c.sort(function(d,e){return d.a==e.a?Qc(d.b,e.b):Ye(d.a.a,e.a.a)}),Ab(m.c,function(f){var h=c;return c=f,h!=null&&lg(c,h)})}}function ib(c,a,b){b==c.d&&a&&L(a)==c.d.c&&c.c.push(a)}function _c(b,a){ib(b,a.b,a),jb(b,a.p),jb(b,a.B),jb(b,N(a))}function Cf(c,a){ib(c,a.b,a),ib(c,a.b,a.s),jb(c,a.o),jb(c,a.k);for(var d=0,e=a.i,f=e.length;d<f;d=d+1|0){var b=e[d];_c(c,b)}}function Df(c,a){ib(c,a.b,a);for(var d=0,e=a.g,f=e.length;d<f;d=d+1|0){
var b=e[d];_c(c,b)}}function jb(c,a){if(a){for(var b=a.g;b;b=b.k)jb(c,b);switch(a.b){case 23:ib(c,a.c,a.e);break;case 21:ib(c,a.d,a.e);break;case 26:ib(c,a.c,a.f.a);break;case 2:_c(c,a.e);break;case 11:Cf(c,a.e);break;case 16:Df(c,a.e);break}}}function Ef(c,a){Aa(c,'keyword','false'),Aa(c,'keyword','true'),Aa(c,'keyword','void');for(var d=0,e=Ng.length;d<e;d=d+1|0){var b=Ng[d];Aa(c,'struct',b.a.c).c=wc(b.a)}$c(c,a,!0)}function Zd(b,a){return a!=null&&a.a==b.a&&gc(a,b.b)}function Aa(d,a,b){var c=null;return d.c.has(b)?c=d.c.get(b):(c=new Dh(a,b),d.d.push(c),Na(d.c,b,c)),c}function ac(d,a){var b=a instanceof oc?'function':a instanceof Tb?'struct':'variable',c=Aa(d,b,a.c);c.c!=''?c.c+='\n':c.d=xc(a.f),c.c+=wc(a)}function $c(B,a,b){if(!a)return!1;var c=Zd(B,a.c);switch(a.b){case 11:if(ac(B,a.e),c){var d=a.e;Aa(B,'keyword','discard'),Aa(B,'keyword','return');for(var U=0,F=d.i,Q=F.length;U<Q;U=U+1|0){var e=F[U];ac(B,e)}$c(B,d.k,!1)}break;case 2:ac(B,a.e);break;case 16:ac(B,a.e);break;case 10:case 19:case 7:c&&(Aa(B,
'keyword','break'),Aa(B,'keyword','continue'));break;case 21:var f=a.g;if(c&&!Zd(B,f.c)){B.d=[];var h=f.f;switch(h){case Lb:case vb:case Fa:case Mb:case wb:case Ga:case Nb:case xb:case Ha:for(var ia=0,M=rd(Ea(h)),ha=M.length;ia<ha;ia=ia+1|0)for(var m=M[ia],l=1;l<5;l=l+1|0){for(var g=[],i=0;i<l;i=i+1|0)g.push(0);for(;;){for(var o='',k=0;k<l;k=k+1|0)o+=m[g[k]];var r=sd(fa(h),o.length).a;Aa(B,'variable',o).c=r.c+' '+o+';';for(var s=0;s<l;){var w=g[s];if((w=w+1|0)^m.length||(w=0),g[s]=w,w)break;s=s+1|0}if(s==l)break}}break;default:if(h.a&&h.a instanceof Tb)for(var Z=0,$=h.a.g,ca=$.length;Z<ca;Z=Z+1|0){var p=$[Z];ac(B,p)}break}return!0}break}if(b||c||a.b==17)for(var C=a.g;C;C=C.k)if($c(B,C,!1))return!0;return c}function _d(b,a){return a!=null&&a.a==b.a&&gc(a,b.b)}function ad(la,a){if(!a||a.b&&!_d(la,a.c))return!1;for(var b=a.g;b;b=b.k)if(ad(la,b))return!0;switch(a.b){case 11:return ad(la,a.e.k),!0;case 20:var c=a.g;if(!_d(la,c.c)){for(var d=c.k,e=c.f,f=e.a,h=[],m=d;m;m=m.k)h.push(m);if(f instanceof oc){for(var l=[],g=f;g;g=g.r)~l.indexOf(g.s)||l.push(g);
l.reverse();for(var rb=0,La=l.length;rb<La;rb=rb+1|0){var i=l[rb];la.c.push(new Fh(wc(i),i.i.map(function(o){return $b(o)}),xc(i.f)))}if(la.c.length){la.e=0;for(var k=[],r=0;r<l.length;r=r+1|0)k.push(r);for(var s=h.length;s>0;s=s-1|0){for(var w=[],Va=0,wa=k,xa=wa.length;Va<xa;Va=Va+1|0){var p=wa[Va];l[p].i.length>=s&&w.push(p)}if(w.length){k=w;break}}if(k.length>1){var C=k.slice();Ab(C,function(B){for(var U=l[B].i,F=0,eb=Math.min(U.length,h.length);F<eb;F=F+1|0){var Q=U[F].p.f,ia=h[F].f;if(ia!=K&&Q!=ia)return!0}return!1}),C.length||(C=k.slice(),Ab(C,function(M){for(var ha=l[M].i,Z=0,Ia=Math.min(ha.length,h.length);Z<Ia;Z=Z+1|0){var $=ha[Z].p.f,ca=h[Z].f,ua=Ea($),aa=Ea(ca);if(ca!=K&&$!=ca&&(!ua||!aa||ua^aa))return!0}return!1})),C.length&&(k=C)}k.length&&(la.e=k[0])}}if(f instanceof Tb&&!fa(e)){var ka=f.g.map(function(va){return $b(va)});la.c.push(new Fh(f.c+'('+ka.join(', ')+');',ka,xc(f.f))),la.e=0}if(h.length){la.d=0;for(var Ja=0,fb=h.length;Ja<fb;Ja=Ja+1|0){var Ua=h[Ja];if(la.b<=Ua.c.c||!Ua.k)break;la.d=la.d+1|0}}
return!0}break}return!1}function Wd(a){switch(a.b){case 30:return (a.h|0).toString();case 28:return (!!a.h).toString();case 29:return Jd(a.h,0);case 20:for(var b=a.g,c=D(a.f)+'(',d=b.k;d;d=d.k)d.o!=b&&(c+=', '),c+=Wd(d);return c+')'}return null}function wc(a){if(a instanceof Tb){var b=a,c=$a(b.e)+'struct '+a.c;if(b.a>-1){c+=' {\n';for(var i=0,o=b.g,k=o.length;i<k;i=i+1|0){var d=o[i];c+='  '+$b(d)+';\n'}c+='}'}return c+';'}if(a instanceof Ge){var e=a,f=$b(e);if(e.h){var h=Wd(e.h);h!=null&&(f+=' = '+h)}return f+';'}if(a instanceof oc){for(var m=a,l=$a(m.e)+D(m.o.f)+' '+a.c+'(',r=0,s=m.i,w=s.length;r<w;r=r+1|0){var g=s[r];g!=m.i[0]&&(l+=', '),l+=$b(g)}return l+');'}return null}function $b(a){var b=a.p.f,c=$a(a.e)+D(b.b||b)+' '+a.c;return b.b&&(c+=b.c?'['+b.c+']':'[]'),c}function xc(a){var b='';if(a)for(var f=0,h=a.length;f<h;f=f+1|0){var c=a[f],d=0,e=c.length;for(c.startsWith('//')?d=d+2|0:c.startsWith('/*')&&(d=d+2|0,e=e-2|0);d<e&&c.charCodeAt(d)==32;)d=d+1|0;for(;e>d&&c.charCodeAt(e-1|0)==32;)e=e-1|0;b!=''&&(b+='\n'),
b+=c.slice(d,e)}return b}function $d(a,b,c){if(!b)return a+': '+c+'\n';var d=ld(b,0);return kd(b)+': '+a+': '+c+'\n'+d.a+'\n'+d.b+'\n'}function Ff(c){for(var a=new nh,d=0,e=c.a,f=e.length;d<f;d=d+1|0){var b=e[d];a.a+=$d(b.a?'warning':'error',b.b,b.c),b.d&&(a.a+=$d('note',b.d,b.e))}return a.a}function u(c,a,b){(!c.d||c.d.b^a.b)&&(c.d=a,c.a.push(new Hh(0,a,b)),c.c=c.c+1|0)}function Gf(c,a,b){c.a.push(new Hh(1,a,b)),c.b=c.b+1|0}function zc(d,a,b){var c=Rc(d.a);c.d=a,c.e=b}function Hf(b,a){u(b,a,'"'+L(a)+'" is a reserved word')}function If(b,a){u(b,a.a,'Unexpected '+Oe[a.b])}function Jf(b,a){u(b,a,'There is no symbol called "'+L(a)+'" in the current scope')}function bd(c,a,b){u(c,a,'There is already a symbol called "'+L(a)+'" in the current scope'),zc(c,b,'The previous definition of "'+L(b)+'" is here')}function Kf(f,a,b,c,d,e){u(f,a,'Cannot change the return type of "'+b+'" to type "'+D(c)+'"'),zc(f,e,'The forward declaration of "'+b+'" has a return type of "'+D(d)+'"')}function ae(b,a){u(b,a,'The operator "'+L(a)+'" is reserved and cannot be used')}
function Lf(e,a,b,c,d){u(e,a,'The constructor for type "'+D(b)+'" only takes '+c+' argument'+(c^1?'s':'')+' and this argument would bring the total to '+d)}function Mf(d,a,b,c){u(d,a,'Cannot construct type "'+D(b)+'" with '+c+' argument'+(c^1?'s':''))}function Nf(f,a,b,c,d,e){u(f,a,'Expected '+b+' argument'+(b^1?'s':'')+' but found '+c+' argument'+(c^1?'s':'')+' when calling function "'+d+'"'),e&&zc(f,e,'The definition of function "'+d+'" is here')}function Of(f,a,b,c,d,e){u(f,a,'Expected '+b+' argument'+(b^1?'s':'')+' but found '+c+' argument'+(c^1?'s':'')+' when constructing type "'+d+'"'),e&&zc(f,e,'The definition of struct "'+d+'" is here')}function Pf(c,a,b){b.b?u(c,a,'Cannot use a conditional expression with array type "'+D(b)+'"'):u(c,a,'Cannot use a conditional expression with type "'+D(b)+'" because it contains an array')}function be(c,a,b){b.b?u(c,a,'Cannot assign to array type "'+D(b)+'"'):u(c,a,'Cannot assign to type "'+D(b)+'" because it contains an array')}function Qf(e,a,b,c,d){c==d?u(e,a,'There is no operator "'+b+'" defined for type "'+D(c)+'"'):u(e,
a,'No binary operator "'+b+'" for type "'+D(c)+'" and type "'+D(d)+'"')}function de(b,a){b.b=a.b,b.c=a.c,b.d=a.d,b.e=a.e,b.f=a.f,b.h=a.h,b.m=a.m}function ee(b){var a=new Jh(b.b);return de(a,b),a}function fd(b){for(var a=ee(b);b.g;)n(a,q(b.g));return a}function Ya(c){for(var a=ee(c),b=c.g;b;b=b.k)n(a,Ya(b));return a}function H(b,a){a!=b&&(de(b,a),Uf(b),Tf(b,a))}function fe(a){return a.g!=null&&a.g==a.i}function bc(c,a){for(var b=c.g;a;)b=b.k,a=a-1|0;return b}function t(b,a){return b.f=a,b}function Cc(b,a){return b.e=a,b}function Ba(b,a){return b.h=+a,b}function _(b,a){return b.h=a,b}function ma(b,a){return b.h=a,b}function cc(b,a){return b.m=a,b}function v(b,a){return b.c=a,b}function Qa(b,a){return b.d=a,b}function n(b,a){return a?(a.l=b,b.g?(a.o=b.i,b.i.k=a,b.i=a):b.i=b.g=a,b):b}function Tf(b,a){for(;a.g;)n(b,q(a.g));return b}function q(a){return a.o?a.o.k=a.k:a.l.g=a.k,a.k?a.k.o=a.o:a.l.i=a.o,a.l=null,a.o=null,a.k=null,a}function Uf(a){for(;a.g;)q(a.g)}function ea(b,a){return a.l=b.l,a.o=b.o,a.k=b.k,b.o?b.o.k=a:b.l.g=a,
b.k?b.k.o=a:b.l.i=a,b.l=null,b.o=null,b.k=null,b}function Dc(c,a,b){return b?a?(b.l=c,b.o=a.o,b.k=a,a.o?a.o.k=b:c.g=b,a.o=b,c):n(c,b):c}function ge(a){for(;a.g;)Dc(a.l,a.k,q(a.i));q(a)}function Ra(a){return a.b==28&&!!a.h}function Cb(a){return a.b==28&&!!!a.h}function dc(b,a){return b.b==30&&(b.h|0)==a||b.b==29&&b.h==a}function Vf(a){return a.l!=null&&a.l.b==20&&a.l.g==a}function he(a){return a.l!=null&&(ed(a.l.b)||Bc(a.l.b)&&a.l.g==a)}function ie(a){return he(a)?!0:a.l&&(a.l.b==21||a.l.b==43)?ie(a.l):!1}function je(a){return a.b==3&&a.g==null}function gd(a){return a.b==25&&a.g==null}function Wf(a){return a.b==30&&(a.h|0)<0||a.b==29&&a.h<0}function na(a){switch(a.b){case 28:case 29:case 30:case 23:return!0;case 22:return na(a.g)&&na(a.g.k)&&na(a.i);case 21:return na(a.g)}return dd(a.b)?!ed(a.b)&&na(a.g):Ac(a.b)?!Bc(a.b)&&na(a.g)&&na(a.i):!1}function Db(a){switch(a.b){case 28:Ba(a,!!!a.h);break;case 32:H(a,q(a.g));break;case 40:a.b=50;break;case 50:a.b=40;break;case 44:a.b=42;break;case 41:a.b=45;break;case 45:
a.b=41;break;case 42:a.b=44;break;case 25:Db(a.i);break;case 47:a.b=46,Db(a.g),Db(a.i);break;case 46:a.b=47,Db(a.g),Db(a.i);break;default:H(a,t(n(new Jh(32),fd(a)),Y));break}}function oa(d,a){if(d.b==a.b){switch(d.b){case 28:return !!d.h==!!a.h;case 29:return d.h==a.h;case 30:return (d.h|0)==(a.h|0);case 23:return d.e==a.e;case 26:return d.f==a.f;case 21:return oa(d.g,a.g)&&d.e==a.e&&d.m==a.m;case 22:return oa(d.g,a.g)&&oa(d.g.k,a.g.k)&&oa(d.i,a.i);case 20:for(var b=d.g,c=a.g;b&&c;){if(!oa(b,c))return!1;b=b.k,c=c.k}return b==null&&c==null}if(dd(d.b))return oa(d.g,a.g);if(Ac(d.b))return oa(d.g,a.g)&&oa(d.i,a.i)}return!1}function ke(a,b,c,d){return n(n(n(n(new Jh(10),a||new Jh(25)),b||new Jh(25)),c||new Jh(25)),d)}function sa(a){return t(n(new Jh(20),t(new Jh(26),a)),a)}function kb(a){return gd(a.g)?null:a.g}function Ca(a){return gd(a.g.k)?null:a.g.k}function Ec(a){return gd(a.i.o)?null:a.i.o}function le(){return Pe=Pe+1|0,Pe}function ba(a){return function(b,c){return v(t(new Jh(26),a),c.a)}}function ec(a){return function(b,c,d){
return Qa(v(n(new Jh(a),d),_a(c.a,d.c)),c.a)}}function me(a){return function(b,c,d){return Qa(v(n(new Jh(a),c),_a(c.c,d.a)),d.a)}}function W(a){return function(b,c,d,e){return Qa(v(n(n(new Jh(a),c),e),_a(c.c,e.c)),d.a)}}function Xf(a){return a.length>1&&a.charCodeAt(0)==48&&a.charCodeAt(1)^120&&a.charCodeAt(1)^88?parseInt(a,8):a|0}function Yf(){var a=new Oh,b=function(c,d,e){return ae(c.a,d.a),v(t(new Jh(27),K),_a(d.a,e.c))},f=function(h,m,l,g){return ae(h.a,l.a),v(t(new Jh(27),K),_a(m.c,g.c))};return P(a,36,function(i,o){return v(t(Ba(new Jh(28),!0),Y),o.a)}),P(a,13,function(k,r){return v(t(Ba(new Jh(28),!1),Y),r.a)}),P(a,97,function(s,w){return v(t(_(new Jh(30),Xf(L(w.a))),ga),w.a)}),P(a,95,function(p,C){return v(t(ma(new Jh(29),+L(C.a)),da),C.a)}),P(a,3,ba(Y)),P(a,5,ba(Lb)),P(a,6,ba(Mb)),P(a,7,ba(Nb)),P(a,14,ba(da)),P(a,20,ba(ga)),P(a,22,ba(vb)),P(a,23,ba(wb)),P(a,24,ba(xb)),P(a,26,ba(ob)),P(a,27,ba(pb)),P(a,28,ba(qb)),P(a,39,ba(Fa)),P(a,40,ba(Ga)),P(a,41,ba(Ha)),P(a,42,ba(yd)),Ib(a,46,14,b),Ib(a,47,14,ec(34)),
Ib(a,48,14,ec(35)),Ib(a,62,14,ec(31)),Ib(a,49,14,ec(32)),Ib(a,65,14,ec(33)),ve(a,47,15,me(36)),ve(a,48,15,me(37)),R(a,53,13,W(39)),R(a,54,10,W(40)),R(a,55,10,W(41)),R(a,56,10,W(42)),R(a,57,10,W(44)),R(a,58,10,W(45)),R(a,62,12,W(51)),R(a,63,13,W(49)),R(a,64,10,W(50)),R(a,65,12,W(38)),R(a,66,13,f),R(a,67,11,f),R(a,68,11,f),R(a,60,3,W(47)),R(a,61,4,W(48)),R(a,59,5,W(46)),R(a,50,8,f),R(a,51,6,f),R(a,52,7,f),ta(a,69,2,W(52)),ta(a,70,2,W(53)),ta(a,71,2,f),ta(a,72,2,f),ta(a,73,2,f),ta(a,74,2,W(54)),ta(a,75,2,W(55)),ta(a,76,2,f),ta(a,77,2,f),ta(a,78,2,f),ta(a,79,2,W(56)),P(a,96,function(B,U){var F=L(U.a),Q=pd(B.l,F);return Q?(Q.m!=null&&ya(B.c.a,Q.m,0)==1&&u(B.a,U.a,'Cannot use "'+F+'" from disabled extension "'+Q.m+'"'),v(Q instanceof Tb?t(new Jh(26),J(Q)):Cc(new Jh(23),Q),U.a)):(Jf(B.a,U.a),v(t(new Jh(24),K),U.a))}),R(a,81,1,function(ia,M,ha,Z){return M.b^25&&(M=v(n(new Jh(25),M),M.c)),n(M,Z),v(M,A(ia,M.c))}),Da(a,82,16).c=function($,ca){var ua=y($).a;E($);var aa=y($).a;return z($,96)?Qa(v(cc(n(new Jh(21),ca),L(aa)),
A($,ca.c)),aa):Qa(v(cc(n(new Jh(21),ca),''),A($,ca.c)),xe(ua))},Da(a,85,0).b=function(ka){var va=E(ka),Ua=T(a,ka,0);return !Ua||!z(ka,89)?v(t(new Jh(24),K),A(ka,va.a)):v(Ua,A(ka,va.a))},Da(a,85,15).c=function(la,rb){var La=E(la),Va=n(new Jh(20),rb);return Zf(la,Va,89)?Qa(v(Va,A(la,rb.c)),A(la,La.a)):v(t(new Jh(24),K),A(la,La.a))},Da(a,84,16).c=function(wa,xa){var eb=E(wa);if(y(wa).b==88)return Gb(wa),E(wa),v(t(new Jh(24),K),A(wa,eb.a));var Ia=T(a,wa,0);return !Ia||!z(wa,88)?v(t(new Jh(24),K),A(wa,eb.a)):Qa(v(n(n(new Jh(43),xa),Ia),A(wa,xa.c)),A(wa,eb.a))},Da(a,86,2).c=function(Ja,fb){var sb=E(Ja),tb=T(a,Ja,1);if(!tb||!z(Ja,80))return v(t(new Jh(24),K),A(Ja,sb.a));var bb=T(a,Ja,1);return bb?v(n(n(n(new Jh(22),fb),tb),bb),A(Ja,fb.c)):v(t(new Jh(24),K),A(Ja,sb.a))},a}function Zf(a,b,c){for(var d=!0;!O(a,c);){d||z(a,81);var e=y(a),f=T(db,a,1);if(f)n(b,f);else if(n(b,v(t(new Jh(24),K),A(a,e.a))),y(a).b^81&&y(a).b^c)return!1;d=!1}return!0}function _f(a){var b=E(a);a.l=new Vh(3,a.l);var c=Za(a,2);if(!c||!z(a,43)||!z(a,
85))return null;var d=T(db,a,0);return !d||!z(a,89)?null:(Hb(a),Eb(a,b.a,n(n(new Jh(7),c),d)))}function $f(a){var b=E(a),c=a.h;if(a.h|=b.b^44?2048:1024,O(a,83)){var d=new Jh(13);return !fc(a,d,1)||!z(a,87)?null:(a.h=c,v(d,A(a,b.a)))}var e=Za(a,1);return e&&(a.h=c,e)}function bg(a){var b=E(a),c=y(a).a;if(!z(a,96))return null;var d=L(c);if(O(a,83)){a.c.a.has(d)||Na(a.c.a,d,0);var e=new Jh(13);if(!fc(a,e,1)||!z(a,87))return null;for(var f=e.g;f;f=f.k)if(f.b^17)f.e&&(f.e.m=d);else for(var h=f.g.k;h;h=h.k)h.e.m=d;return v(e,A(a,b.a))}if(!bh.has(d)&&!a.c.a.has(d)&&Gf(a.a,c,'The extension "'+d+'" is not in the known list of valid WebGL extensions'),!z(a,80))return null;var m=L(y(a).a);if(!ag.has(m))return Gb(a),null;E(a);var l=ag.get(m);return Na(a.c.a,d,l),Qa(v(_(cc(new Jh(9),d),l),A(a,b.a)),c)}function cg(a){var b=E(a);if(a.l=new Vh(3,a.l),!z(a,85))return null;var c=null;if(!O(a,90)){var d=pe(a),e=hd(a,2),f=null;if(e){if(f=Fb(a,1),!f)return null}else f=Fb(a,0);if(f){if(c=oe(a,b.a,e,f,0,d),!c)return null}else if((c=T(db,
a,0),!c)||!z(a,90))return null}var h=null;if(!O(a,90)&&((h=T(db,a,0),!h)||!z(a,90)))return null;var m=null;if(!O(a,89)&&((m=T(db,a,0),!m)||!z(a,89)))return null;var l=Za(a,2);return l&&(Hb(a),v(ke(c,h,m,l),A(a,b.a)))}function dg(a){var b=E(a);if(!z(a,85))return null;var c=y(a),d=T(db,a,0);if(d||(d=v(t(new Jh(24),K),A(a,c.a))),!z(a,89))return null;var e=Za(a,2);if(!e)return null;var f=null;return O(a,12)&&(f=Za(a,2),!f)?null:v(n(n(n(new Jh(12),d),e),f),A(a,b.a))}function eg(a){var b=E(a),c=y(a).a;return z(a,97)?v(_(new Jh(18),L(c)|0),A(a,b.a)):null}function fg(a){var b=E(a);if(a.l=new Vh(3,a.l),!z(a,85))return null;var c=y(a),d=T(db,a,0);if(d||(d=v(t(new Jh(24),K),A(a,c.a))),!z(a,89))return null;var e=Za(a,2);return e&&(Hb(a),v(n(n(new Jh(19),d),e),A(a,b.a)))}function gg(a){var b=E(a),c=null;if(!O(a,90)){var d=y(a);c=T(db,a,0),c||(c=v(t(new Jh(24),K),A(a,d.a))),z(a,90)}return v(n(new Jh(15),c),A(a,b.a))}function hg(a){var b=E(a),c=0;switch(y(a).b){case 25:c=32;break;case 29:c=64;break;case 16:c=4;break;default:
return Gb(a),null}E(a);var d=Fb(a,1);return d&&Eb(a,b.a,n(_(new Jh(14),c),d))}function ig(a,b,c){var d=y(a).a;if(!z(a,96))return null;var e=new Tb(sc(a.c),d,L(d),new Vh(4,a.l));if(e.e|=a.h|b,e.f=c,!id(a,e))return null;var f=y(a).a,h=new Jh(1),m=null;if(!z(a,83))return null;for(a.l=e.d;y(a).b^87&&y(a).b^99;){var l=Za(a,3);if(!l)return null;if(l.b^17)u(a.a,l.c,'This statement cannot be used inside a struct');else{n(h,l);for(var g=l.g.k;g;g=g.k){var i=g.e;e.g.push(i),N(i)&&u(a.a,N(i).c,'Cannot initialize struct variables')}}}if(Hb(a),!z(a,87))return null;if(v(h,A(a,f)),y(a).b^96)z(a,90);else if(m=te(0,t(new Jh(26),J(e)),E(a).a,a,c),!m)return null;return n(n(Cc(new Jh(16),e),h),m)}function ne(a,b,c){for(var d=!1,e=a.l;e;e=e.b)if(e.a==3){d=!0;break}return d||u(a.a,b,'This statement cannot be used outside a loop'),Eb(a,b,c)}function Eb(a,b,c){return z(a,90),v(c,A(a,b))}function oe(a,b,c,d,e,f){var h=y(a).a;if(!c&&y(a).b^96){var m=ue(db,a,0,d);return m&&Eb(a,b,n(new Jh(8),m))}if(!z(a,96))return null;if(O(a,85))return kg(c,
d,h,a,f);var l=te(c,d,h,a,f);return l&&v(l,A(a,b))}function pe(a){var b=y(a),c=b.c;if(!c)return null;for(var d=b.a.b,e=null,f=c.length-1|0;f>-1;f=f-1|0){for(var h=c[f],m=h.a.b.slice(h.c,d),l=0,g=0;g<m.length;g=g+1|0){var i=m.charCodeAt(g);(i==13||i==10)&&(l=l+1|0,i==13&&(g+1|0)<m.length&&m.charCodeAt(g+1|0)==10&&(g=g+1|0))}if(l>1)break;(e||(e=[])).push(L(h)),d=h.b}return e&&e.reverse(),e}function Za(a,b){var c=y(a);switch(c.b){case 4:return ne(a,E(a).a,new Jh(4));case 9:return ne(a,E(a).a,new Jh(5));case 10:return Eb(a,E(a).a,new Jh(6));case 11:return _f(a);case 44:case 45:return $f(a);case 91:return bg(a);case 15:return cg(a);case 17:return dg(a);case 83:return re(a);case 31:return hg(a);case 32:return gg(a);case 90:return v(new Jh(3),E(a).a);case 92:return eg(a);case 43:return fg(a)}var d=pe(a),e=hd(a,b),f=null;if(O(a,35)){var h=ig(a,e,d);return h&&v(h,A(a,c.a))}if(e){if(f=Fb(a,1),!f)return null}else f=Fb(a,0);if(f)return oe(a,c.a,e,f,1,d);var m=T(db,a,0);return m&&Eb(a,c.a,n(new Jh(8),m))}function qe(a,b){if(b.b^17&&b.b^16){
var c=a.l.a==1||a.l.a==4,d=b.b==9||b.b==11||b.b==14||b.b==18;d&&!c?u(a.a,b.c,'This statement cannot be used inside a function'):!d&&c&&u(a.a,b.c,'This statement cannot be used outside a function')}}function jg(a,b){var c=y(a).a;if(!z(a,98))return!1;var d=null;try{d=JSON.parse(L(c))}catch(l){return u(a.a,c,'Invalid string literal'),!1}var e=a.c.b;if(!e)return u(a.a,c,'Cannot include files without access to a file system'),!1;var f=e(d,c.a.a);if(!f)return u(a.a,c,'Cannot read the file '+JSON.stringify(d)),!1;if(a.e.has(f.a))return!0;Na(a.e,f.a,!0),a.f.push(new Lh(c,Cg(f)));var h=Jc(a.a,f,0),m=new Mh(a.a,h,a.c,a.d,a.e);return m.l=a.l,!fc(m,b,1)||!z(m,99)?!1:!0}function re(a){var b=y(a),c=new Jh(3);return a.l=new Vh(2,a.l),!z(a,83)||!fc(a,c,2)||!z(a,87)?null:(Hb(a),v(c,A(a,b.a)))}function hd(a,b){for(var c=0;;){var d=y(a).b;switch(d){case 2:c|=1;break;case 8:c|=2;break;case 16:c|=4;break;case 18:c|=8;break;case 19:c|=16;break;case 25:c|=32;break;case 29:c|=64;break;case 30:c|=128;break;case 37:c|=256;break;case 38:
c|=512;break;default:return c}(!b&&(d==2||d==37||d==38)||b==3&&d^25&&d^29&&d^16||b&&(d==18||d==30||d==19))&&u(a.a,y(a).a,'Cannot use this qualifier here'),E(a)}}function Fb(a,b){var c=y(a),d=null;switch(c.b){case 3:d=Y;break;case 5:d=Lb;break;case 6:d=Mb;break;case 7:d=Nb;break;case 14:d=da;break;case 20:d=ga;break;case 22:d=vb;break;case 23:d=wb;break;case 24:d=xb;break;case 26:d=ob;break;case 27:d=pb;break;case 28:d=qb;break;case 33:d=Lg;break;case 34:d=Mg;break;case 39:d=Fa;break;case 40:d=Ga;break;case 41:d=Ha;break;case 42:d=yd;break;case 96:var e=pd(a.l,L(c.a));if(!e||!(e instanceof Tb))return b^1||Gb(a),null;d=J(e);break;default:return b^1||Gb(a),null}return E(a),v(t(new Jh(26),d),A(a,c.a))}function kg(a,b,c,d,e){var f=d.l,h=new oc(sc(d.c),c,L(c),new Vh(0,f));if(h.e|=d.h|a|(h.c=='main'?1024:0),h.f=e,h.o=b,d.l=h.d,O(d,42)){if(!z(d,89))return null}else if(!O(d,89)){for(;;){var m=hd(d,0),l=Fb(d,1);if(!l)return null;var g=y(d).a;if(!z(d,96))return null;var i=new Ge(sc(d.c),g,L(g),d.l,0);if(i.e|=m,i.p=l,h.i.push(i),
id(d,i),!se(d,i))return null;if(!O(d,81))break}if(!z(d,89))return null}var o=ya(f.c,L(c),null),k=!O(d,90);if(o){if(o instanceof oc){for(var r=o;r;r=r.r)if(Eg(r,h)){r.o.f!=h.o.f?Kf(d.a,h.o.c,h.c,h.o.f,r.o.f,r.o.c):r.k||!k?bd(d.a,h.b,r.b):(r.s=h,h.s=r,h.e|=r.e,r.e=h.e);break}h.r=o,Bg(f,h)}else return bd(d.a,c,o.b),null}else Fe(f,h);if(k){var s=d.h;if(d.h&=-3073,h.k=re(d),d.h&=s,!h.k)return null}return Hb(d),v(Cc(new Jh(11),h),A(d,b.c))}function se(a,b){var c=y(a);if(O(a,84)){if(O(a,88))return u(a.a,A(a,c.a),'All array sizes must be specified'),!0;if(b.B=T(db,a,0),!b.B||!z(a,88))return!1;var d=0;if(X(a.d,b.B),pa(a.d,b.B,ga),b.B.f!=K){var e=G(b.B);if(e){if(e.b==30){var f=e.h|0;f<1?u(a.a,b.B.c,'Cannot declare an array with a size of "'+f+'"'):d=f}}else u(a.a,b.B.c,'This value must be a compile-time constant')}for(;y(a).b==84;){if(c=E(a),y(a).b^88&&!T(db,a,0)||!z(a,88))return!1;u(a.a,A(a,c.a),'Multidimensional arrays are not a part of the language')}b.p=v(t(new Jh(26),Ig(b.p.f,d)),b.p.c)}return!0}function te(a,b,c,d,e){
for(var f=n(_(new Jh(17),d.h|a),b);;){var h=new Ge(sc(d.c),c,L(c),d.l,d.l.a^1?d.l.a^4?2:3:1);if(h.e|=d.h|a,h.f=e,h.p=b,!se(d,h))return null;var m=y(d).a,l=null;if(O(d,69)){var g=y(d);l=T(db,d,1),l||(l=v(t(new Jh(24),K),A(d,g.a)))}else m=null;var i=Qa(v(n(Cc(new Jh(2),h),l),A(d,h.b)),m);if(h.C=i,h.e&2&&X(d.d,i),n(f,i),id(d,h),!O(d,81))return z(d,90),f;if(c=y(d).a,!z(d,96))return null}}function id(a,b){var c=ya(a.l.c,b.c,null);return c?(bd(a.a,b.b,c.b),!1):(Fe(a.l,b),!0)}function fc(a,b,c){for(;y(a).b^99&&y(a).b^87;){var d=y(a).a;if(O(a,93)){if(c^1)return u(a.a,d,'"#include" statements cannot be used here'),O(a,98),!1;if(!jg(a,b))return!1}else{var e=Za(a,c);if(!e)return!1;if(e.b^13)qe(a,e),n(b,e);else for(;e.g;){var f=q(e.g);qe(a,f),n(b,f)}}}return!0}function jd(a,b,c,d,e,f){db||(db=Yf());var h=new Map,m=new Mh(a,b,d,f,h);return m.l=e,fc(m,c,1)&&z(m,99),new Kh(m.f)}function y(a){return a.b[a.m]}function E(b){var a=y(b);return (b.m+1|0)<b.b.length&&(b.m=b.m+1|0),a}function A(c,a){var b=c.b[c.m>0?c.m-1|0:0];return b.a.c<a.b?a:_a(a,
b.a)}function O(b,a){return y(b).b^a?!1:(E(b),!0)}function z(e,a){if(O(e,a))return!0;var b=y(e),c=b.a,d=(e.m>0?e.b[e.m-1|0]:b).a;return a==90||we(d).a^we(c).a?u(e.a,xe(d),'Expected '+Oe[a]):u(e.a,c,'Expected '+Oe[a]+' but found '+Oe[b.b]),!1}function Gb(a){If(a.a,y(a))}function Hb(a){a.l=a.l.b}function Da(e,a,b){var c=ra(e.a,a,null);if(c)b>c.a&&(c.a=b);else{var d=new Nh(b);c=d,za(e.a,a,d)}return c}function T(f,a,b){var c=y(a),d=ra(f.a,c.b,null);if(!d||!d.b)return Gb(a),null;var e=ue(f,a,b,d.b(a));return e}function ue(f,a,b,c){for(;c;){var d=y(a).b,e=ra(f.a,d,null);if(!e||!e.c||e.a<=b)break;c=e.c(a,c)}return c}function P(d,a,b){Da(d,a,0).b=function(c){return b(c,E(c))}}function Ib(h,a,b,c){Da(h,a,0).b=function(d){var e=E(d),f=T(h,d,b);return f&&c(d,e,f)}}function ve(f,a,b,c){Da(f,a,b).c=function(d,e){return c(d,e,E(d))}}function R(m,a,b,c){Da(m,a,b).c=function(d,e){var f=E(d),h=T(m,d,b);return h&&c(d,e,f,h)}}function ta(m,a,b,c){Da(m,a,b).c=function(d,e){var f=E(d),h=T(m,d,b-1|0);return h&&c(d,e,f,h)}}function L(a){
return a.a.b.slice(a.b,a.c)}function kd(b){var a=Jb(b.a,b.b);return b.a.a+':'+(a.a+1|0)+':'+(a.b+1|0)}function lg(b,a){return b.a==a.a&&b.b<a.c&&a.b<b.c}function gc(b,a){return b.b<=a&&a<=b.c}function ld(C,a){for(var b=Jb(C.a,C.b),c=Jb(C.a,C.c),d=Dg(C.a,b.a),e=b.b,f=c.a^b.a?d.length:c.b,h=Ue($g,d,0),m=[],l=0,g=0;;){h.b^e||(l=m.length),h.b^f||(g=m.length);var i=Ve(h);if(i<0)break;if(i^9)m.push(i);else for(var o=0,B=8-m.length%8|0;o<B;o=o+1|0)m.push(32)}var k=m.length;if(a>0&&k>a){var r=Math.min(g-l|0,a/2|0),s=Math.max((a-r|0)/2|0,3);if(l<s)d=rc(m.slice(0,a-3|0))+'...',g>(a-3|0)&&(g=a-3|0);else if((k-l|0)<(a-s|0)){var w=k-a|0;d='...'+rc(m.slice(w+3|0,k)),l=l-w|0,g=g-w|0}else{var p=l-s|0;d='...'+rc(m.slice(p+3|0,(p+a|0)-3|0))+'...',l=l-p|0,g=g-p|0,g>(a-3|0)&&(g=a-3|0)}}else d=rc(m);return new Ph(d,Yb(' ',l)+((g-l|0)<2?'^':Yb('~',g-l|0)))}function mg(c,a,b){return new Qh(c.a,c.b+a|0,c.b+b|0)}function we(a){return Jb(a.a,a.b)}function xe(a){return new Qh(a.a,a.c,a.c)}function _a(a,b){return new Qh(a.a,a.b,b.c)}function ng(a){
var b='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_'[a%53];for(a=a/53|0;a>0;)a=a-1|0,b+='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789'[a%63],a=a/63|0;return b}function og(o,a){for(var b=0,k=a.length;b<k;b=b+1|0)o.h=b,lb(o,a[b]);qg(o);var c=new Map,d=ye(o,o.f,null);d.sort(function(e,f){return Qc(ze(o,f),ze(o,e))});for(var B=0,U=d.length;B<U;B=B+1|0)for(var h=d[B],m=null,p=0,C=h.length;p<C;p=p+1|0)for(var l=h[p],r=0,s=Array.from(l.c.values()),w=s.length;r<w;r=r+1|0){var g=s[r],i=g.c;!(g.e&3072)&&(!o.a||o.a==1&&!(g.e&257))&&(m==null&&(m=pg(o)),g.c=m),!(g.e&2048)&&g.e&257&&Na(c,i,g.c)}return c}function lb(f,a){var m,h;a.e&&((h=md(f,a.e)).d=h.d+1|0);for(var b=a.g;b;b=b.k)lb(f,b);switch(a.b){case 2:var c=a.e;lb(f,c.p),N(c)&&lb(f,N(c));break;case 11:var d=a.e;f.l=f.d.get(a.e.a).b,d.s&&xd(f.f,f.l,md(f,d.s).b),lb(f,d.o);for(var l=0,g=d.i,i=g.length;l<i;l=l+1|0){var e=g[l];(m=md(f,e)).d=m.d+1|0,lb(f,e.p)}d.k&&lb(f,d.k),f.l=-1;break}}function md(c,a){var b=ra(c.d,a.a,null);return b||(b=new Sh(a.c,
c.c.length),b.e=td(a),c.c.push(b),za(c.d,a.a,b),Je(c.e),Je(c.f)),b.c.has(c.h)||za(b.c,c.h,a),td(a)&&xd(c.e,c.l,b.b),b}function pg(b){for(;;){var a=ng(b.m);if(b.m=b.m+1|0,!Gg.has(a)&&!Hg.has(a)&&!a.startsWith('gl_'))return a}}function ye(h,a,b){for(var c=new Map,m=0,l=h.c,g=l.length;m<g;m=m+1|0){var d=l[m];if(!b||b(d)){var e=Mc(a,d.b),f=ra(c,e,null);f||(f=[],za(c,e,f)),f.push(d)}}return Array.from(c.values())}function qg(b){rg(b,ye(b,b.e,function(a){return a.e}))}function rg(m,a){for(var b=[],g=0,i=a.length;g<i;g=g+1|0){var c=a[g];c.sort(function(d,e){return Qc(e.d,d.d)});for(var f=0,l=c.length;f<l;f=f+1|0){var h=c[f];f<b.length?xd(m.f,h.b,b[f]):b.push(h.b)}}}function ze(d,a){for(var b=0,e=0,f=a.length;e<f;e=e+1|0){var c=a[e];b=b+c.d|0}return b}function nd(e,a){X(e,a);for(var f=0,h=e.d,m=h.length;f<m;f=f+1|0){var b=h[f];q(b)}var c=a.g;e.d.length&&Dc(a,c,e.d[0]);for(var l=0,g=Array.from(e.e.values()),i=g.length;l<i;l=l+1|0){var d=g[l];Dc(a,c,d)}}function X(p,a){if(!a.f){a.f=K;var b=a.b;switch(b){case 0:case 1:od(p,
a);break;case 2:var c=a.e;X(p,c.p);var d=c.p.f;if(d==yd&&(u(p.a,c.p.c,'Cannot create a variable of type "'+D(d)+'"'),d=K),c.B&&(ja(p,c.B),pa(p,c.B,ga)),N(c)&&(ja(p,N(c)),pa(p,N(c),d),d.d&&be(p.a,a.d,d)),c.e&2)if(N(c)){if(N(c).f!=K){var e=G(N(c));e?c.h=e:u(p.a,N(c).c,'This value must be a compile-time constant')}}else c.w^2||u(p.a,c.b,'Constants must be initialized');break;case 3:mb(p,a);break;case 4:case 5:case 6:break;case 7:mb(p,a.g),X(p,a.i),pa(p,a.i,Y);break;case 8:X(p,a.g);break;case 9:break;case 10:kb(a)&&ja(p,kb(a)),Ca(a)&&(ja(p,Ca(a)),pa(p,Ca(a),Y)),Ec(a)&&ja(p,Ec(a)),mb(p,a.i);break;case 11:for(var f=a.e,C=0,B=f.i,U=B.length;C<U;C=C+1|0){var h=B[C];X(p,h.p)}X(p,f.o),f.k&&(p.f=f.o.f,mb(p,f.k),p.f&&p.f!=yd&&f.k.r&&u(p.a,f.b,'All control paths for "'+f.c+'" must return a value of type "'+D(p.f)+'"'),p.f=null);break;case 12:X(p,a.g),pa(p,a.g,Y),mb(p,a.g.k),a.g.k.k&&mb(p,a.g.k.k);break;case 14:break;case 15:a.g?(X(p,a.g),pa(p,a.g,p.f||K)):(a.f=yd,pa(p,a,p.f||K));break;case 16:od(p,a);for(var m=J(a.e),F=0,Q=a.e.g,ia=Q.length;F<ia;F=F+1|0){
var l=Q[F],g=l.p.f;g.d&&(m.d=!0),g.e&&(m.e=!0)}break;case 17:od(p,a);break;case 18:p.d.push(a);break;case 19:X(p,a.g),pa(p,a.g,Y),mb(p,a.i);break;case 20:ug(p,a);break;case 21:vg(p,a);break;case 22:var i=a.g,o=a.i,k=a.g.k;ja(p,i),pa(p,i,Y),ja(p,k),ja(p,o),k.f!=o.f?u(p.a,_a(k.c,o.c),'Cannot merge type "'+D(k.f)+'" and type "'+D(o.f)+'"'):k.f.d?Pf(p.a,_a(k.c,o.c),k.f):a.f=k.f;break;case 23:var r=a.e;r instanceof Ge?(X(p,r.p),a.f=r.p.f):r instanceof oc&&!Vf(a)?u(p.a,a.c,'The function "'+r.c+'" must be called'):a.f=J(r);var s=r.m;s!=null&&!p.e.has(s)&&!ya(p.b.a,s,0)&&Na(p.e,s,_(cc(new Jh(9),s),2));break;case 25:for(var w=a.g;w;w=w.k)ja(p,w);a.f=a.i.f;break;default:dd(b)?sg(p,a):Ac(b)&&tg(p,a);break}}}function mb(c,a){if(bf(c.c,a),a.b^3)X(c,a),Hd(c.c,a);else for(var b=a.g;b;b=b.k)X(c,b),Hd(c.c,b);cf(c.c,a)}function sg(d,a){var b=a.g;ja(d,b),ed(a.b)&&Ae(d,b);var c=b.f;switch(a.b){case 31:case 33:case 34:case 35:case 36:case 37:a.f=Jg(c)?c:K;break;case 32:a.f=c==Y?Y:K;break}a.f==K&&c!=K&&u(d.a,a.d,'No unary operator "'+L(a.d)+'" for type "'+D(c)+'"')}
function tg(i,a){var b=a.g,c=a.i;ja(i,b),ja(i,c),Bc(a.b)&&Ae(i,b);var d=b.f,e=c.f,f=d==e;switch(a.b){case 38:case 51:case 49:case 39:a.f=f&&fa(d)||Lc(d)&&e==da||Kc(d)&&e==ga?d:d==da&&Lc(e)||d==ga&&Kc(e)?e:a.b==49&&(d==Fa&&e==ob||d==ob&&e==Fa)?Fa:a.b==49&&(d==Ga&&e==pb||d==pb&&e==Ga)?Ga:a.b==49&&(d==Ha&&e==qb||d==qb&&e==Ha)?Ha:K;break;case 40:case 50:a.f=f&&Kg(d)?Y:K;break;case 46:case 47:case 48:a.f=f&&d==Y?Y:K;break;case 44:case 45:case 41:case 42:a.f=f&&(d==da||d==ga)?Y:K;break;case 52:a.f=d,d.d&&be(i.a,a.d,d),pa(i,c,d);return;case 53:case 56:case 55:case 54:a.f=f&&fa(d)||Lc(d)&&e==da||Kc(d)&&e==ga||a.b==55&&(d==Fa&&e==ob||d==Ga&&e==pb||d==Ha&&e==qb)?d:K;break;case 43:if(e==ga){var h=vd(d);h&&(a.f=h);var m=G(c);if(m&&m.b==30){var l=m.h|0,g=Sa(d);(l<0||g&&l>=g)&&u(i.a,c.c,'Index "'+l+'" is out of bounds for type "'+D(d)+'"')}}break}a.f==K&&d!=K&&e!=K&&(a.b^43?Qf(i.a,a.d,L(a.d),d,e):u(i.a,a.d,'No index operator for type "'+D(d)+'" and type "'+D(e)+'"'))}function ug(m,a){var b=a.g;X(m,b);for(var c=b.f,d=c.a,e=[],f=!1,h=b.k;h;h=h.k)ja(m,
h),e.push(h),h.f==K&&(f=!0);if(!f){if(d){if(d instanceof oc){wg(m,d,a,e);return}if(d instanceof Tb){xg(m,c,a,e);return}}c!=K&&u(m.a,b.c,'Cannot call type "'+D(c)+'"')}}function vg(m,a){var b=a.g,c=a.m,d=a.d;if(ja(m,b),c!=''){var e=b.f,f=he(a);switch(e){case Lb:case vb:case Fa:case Mb:case wb:case Ga:case Nb:case xb:case Ha:a.f=yg(m,d,e,c,f);break;case K:break;default:if(e.a&&e.a instanceof Tb)for(var l=0,g=e.a.g,i=g.length;l<i;l=l+1|0){var h=g[l];if(h.c==c){a.e=h,X(m,h.p),a.f=h.p.f;break}}a.e||u(m.a,d,'Cannot find "'+c+'" on type "'+D(e)+'"');break}}}function wg(C,a,b,c){for(var d=[],e=a;e;e=e.r)~d.indexOf(e.s)||d.push(e);if(d.length^1&&(d=d.slice(),Ab(d,function(f){return f.i.length!=c.length}),d.length^1)){var h=d.slice();Ab(d,function(m){for(var l=0,B=c.length;l<B;l=l+1|0)if(m.i[l].p.f!=c[l].f)return!0;return!1}),d.length^1&&(d=h,Ab(d,function(g){for(var i=0,U=c.length;i<U;i=i+1|0){var o=g.i[i].p.f,k=c[i].f,r=Ea(o),s=Ea(k);if(o!=k&&(!r||!s||r^s))return!0}return!1}))}if(d.length^1)u(C.a,b.g.c,'No matching overload for function "'+a.c+'"');
else{var w=d[0];if(w.i.length^c.length)Nf(C.a,b.d,w.i.length,c.length,w.c,w.b);else for(var p=0,F=c.length;p<F;p=p+1|0)pa(C,c[p],w.i[p].p.f);b.g.e=w,b.f=w.o.f}}function xg(w,a,b,c){if(b.f=a,a!=K)if(fa(a)){for(var d=Ea(a),e=!1,f=0,p=0,C=c.length;p<C;p=p+1|0){var h=c[p],m=h.f,l=Ea(m);if(!fa(m)){m!=K&&u(w.a,h.c,'Cannot use value of type "'+D(m)+'" when constructing type "'+D(a)+'"');return}f>=d&&Lf(w.a,h.c,a,d,f+l|0),ab(m)&&(e=!0),f=f+l|0}var g=ab(a)&&e;g&&c.length^1?u(w.a,b.d,'If a matrix argument is given to a matrix constructor, it is an error to have any other arguments'):f<d&&f^1&&!g&&Mf(w.a,b.d,a,f)}else{var i=a.a,o=i.g,k=o.length,r=c.length;if(k^r)Of(w.a,b.d,k,r,i.c,i.b);else for(var s=0;s<k;s=s+1|0)pa(w,c[s],o[s].p.f)}}function yg(l,a,b,c,d){var e=c.length;if(e<1||e>4)return u(l.a,a,'Invalid swizzle "'+c+'" on type "'+D(b)+'"'),K;for(var f=Ea(b),g=0,i=rd(f),o=i.length;g<o;g=g+1|0){var h=i[g];if(~h.indexOf(c[0])){for(var m=1;m<e;m=m+1|0){if(h.indexOf(c[m])==-1)return u(l.a,a,'Invalid swizzle "'+c+'" on type "'+D(b)+'"'),
K;if(d&&~c.slice(0,m).indexOf(c[m]))return u(l.a,mg(a,m,m+1|0),'The field "'+c[m]+'" cannot be specified multiple times when used as a storage location'),K}return sd(fa(b),e)}}return u(l.a,a,'Invalid swizzle "'+c+'" on type "'+D(b)+'"'),K}function ja(b,a){X(b,a),a.b==26&&a.f!=K&&(u(b.a,a.c,'Unexpected type "'+D(a.f)+'"'),a.f=K)}function od(c,a){for(var b=a.g;b;b=b.k)X(c,b)}function Ae(c,a){d:for(var b=a;;){if(b.f==K)break;switch(b.b){case 23:(b.e.e&2||b.e.e&256)&&u(c.a,a.c,'Cannot store to this location');break d;case 21:b=b.g;break;case 43:b=b.g;break;default:u(c.a,a.c,'Cannot store to this location');break d}}}function pa(c,a,b){a.f!=b&&a.f!=K&&b!=K&&u(c.a,a.c,'Cannot convert from type "'+D(a.f)+'" to type "'+D(b)+'"')}function zg(a,b,c){for(;;){var d=new Uh;if(c.a&&Hc(d,a),c.d&&(Fc(d,a),Gc(d,a),Ag(d,a,b)),!d.a)break}c.a&&nb(a)}function nb(a){switch(a.b){case 12:if(!a.g.k.k)return!0;var b=a.g.k,c=nb(b);return c&&b.b^3&&ea(b,n(new Jh(3),fd(b))),nb(a.g.k.k);case 10:return nb(a.i);case 11:var d=a.e;d.k&&nb(d.k);
break;case 19:return nb(a.i);default:for(var e=a.g;e;e=e.k)nb(e);return!1}return!1}function Fc(m,a){for(var b=a.g;b;b=b.k)Fc(m,b);switch(a.b){case 2:var c=a.e;N(c)&&Fc(m,N(c)),(c.w==2||c.w==1)&&(m.b.push(c),za(m.c,c.a,0),za(m.d,c.a,0));break;case 11:var d=a.e;za(m.c,d.a,0),d.k&&Fc(m,d.k);break;case 23:var e=a.e.a,f=ra(m.c,e,-1);~f&&za(m.c,e,f+1|0),ie(a)&&(f=ra(m.d,e,-1),~f&&za(m.d,e,f+1|0));var h=a.e.m;h!=null&&Na(m.e,h,0);break}}function Gc(l,a){for(var b=a.g,c=null;b;b=c)c=b.k,Gc(l,b);switch(a.b){case 2:if(De(l,a.e)||Ee(l,a.e)||Ce(l,a.e)&&(!a.g||na(a.g)||a.e.h))q(a),l.a=!0;else{a.g&&Gc(l,a.g);var d=a.e.B;if(d&&d.b==23){var e=Be(l,d.e);e&&(a.e.B=e,l.a=!0)}}break;case 11:var f=a.e;Ce(l,f)&&!(f.e&1024)?(q(a),l.a=!0):f.k&&Gc(l,f.k);break;case 17:if(!a.g.k){var h=a.l.b;h==3||!h||h==16?q(a):h^10?H(a,new Jh(3)):H(a,new Jh(25)),l.a=!0}break;case 23:var m=Be(l,a.e);m&&(ea(a,m),l.a=!0);break}}function Be(b,a){return De(b,a)?Ya(a.h):Ee(b,a)?Ya(N(a)):null}function Ag(e,a,b){for(var c=a.g,d=null;c;c=d)d=c.k,c.b==9&&!e.e.has(c.m)&&!ya(b.a,
c.m,0)&&q(c)}function Ce(b,a){return ra(b.c,a.a,-1)==0&&(!(a instanceof oc)||a.s==null||ra(b.c,a.s.a,-1)==0)}function De(b,a){return a.h!=null&&cd(a.h.b)}function Ee(b,a){return ra(b.d,a.a,-1)==0&&N(a)!=null&&cd(N(a).b)}function Hc(x,a){for(var b=a.g,c=null;b;b=c)c=b.k,Hc(x,b);switch(a.b){case 2:var d=a.e;N(d)&&Hc(x,N(d));break;case 3:for(var e=a.g;e;e=e.k)if(Sf(e.b)&&e.k){for(;e.k;)q(e.k);x.a=!0}if(a.l&&a.l.b==3){for(var f=!1,h=a.g;h;h=h.k)h.b^17||(f=!0);if(!f){ge(a),x.a=!0;return}}break;case 8:if(a.l.b==3){if(na(a.g)){q(a),x.a=!0;return}var m=a.o;if(m&&m.b==8){var l=q(a.g);n(a,n(n(new Jh(25),q(q(m).g)),l)),x.a=!0;return}}break;case 7:Ic(x,a.g),Cb(a.i)&&(ea(a,n(new Jh(3),q(a.g))),x.a=!0);break;case 10:if(Ic(x,a.i),!kb(a)&&a.o&&a.o.b==8&&(ea(a.g,q(a.o.g)),q(a.o),x.a=!0),Ca(a)&&Ra(Ca(a))&&(ea(Ca(a),new Jh(25)),x.a=!0),a.i.b^5){for(;a.i.g&&a.i.i.b==5;)q(a.i.i),x.a=!0}else ea(a.i,new Jh(3)),x.a=!0;break;case 11:var g=a.e;g.k&&Hc(x,g.k);break;case 12:if(Ic(x,a.g.k),a.g.k.k&&Ic(x,a.g.k.k),Ra(a.g)){ea(a,q(a.g.k)),x.a=!0;
return}if(Cb(a.g)){a.g.k.k?ea(a,q(a.g.k.k)):q(a),x.a=!0;return}if(a.g.k.k&&a.g.k.b==15&&a.g.k.k.b==15){var i=a.g.k.g,o=a.g.k.k.g;if(i&&o){ea(a,n(new Jh(15),t(n(n(n(new Jh(22),q(a.g)),q(i)),q(o)),i.f))),x.a=!0;return}}if(a.g.k.k&&a.g.k.b==8&&a.g.k.k.b==8){var k=a.g.k.g,r=a.g.k.k.g;if(k.f==r.f){ea(a,n(new Jh(8),t(n(n(n(new Jh(22),q(a.g)),q(k)),q(r)),k.f))),x.a=!0;return}}if(!a.g.k.k&&a.g.k.b==8){var s=a.g.k.g,w=s.b==52&&s.g.b==23&&td(s.g.e);if(s.f==ga||s.f==da||w){var p=w?Ya(s.g):s.f==ga?t(_(new Jh(30),0),ga):t(ma(new Jh(29),0),da);ea(a,n(new Jh(8),t(n(n(n(new Jh(22),q(a.g)),q(s)),p),s.f))),x.a=!0;return}}if(!a.g.k.k&&a.g.k.b==12&&!a.g.k.g.k.k){var C=a.g,B=a.g.k.g,U=a.g.k.g.k;H(C,t(n(n(new Jh(46),fd(C)),q(B)),Y)),H(a.g.k,q(U)),x.a=!0;return}if(je(a.g.k)){a.g.k.k?(Db(a.g),q(a.g.k)):ea(a,n(new Jh(8),q(a.g))),x.a=!0;return}if(a.g.k.k&&je(a.g.k.k)){q(a.g.k.k),x.a=!0;return}break;case 15:for(var F=a.o;F&&F.b==12&&!F.g.k.k&&F.g.k.b==15;){var Q=F.g.k.g,ia=a.g;if(!Q||!ia)break;ea(a,n(new Jh(15),t(n(n(n(new Jh(22),q(F.g)),
q(Q)),q(ia)),Q.f))),q(F),F=a.o,x.a=!0}break;case 17:for(var M=a.o;M;M=M.o){if(M.b^17)break;if(M.g.f==a.g.f&&(M.h|0)==(a.h|0)){for(;M.i!=M.g;)Dc(a,a.g.k,q(M.i));q(M),x.a=!0;return}for(var ha=M.g.k;ha;ha=ha.k){var Z=ha.g;if(Z&&!cd(Z.b))return}}break;case 19:var $=a.g,ca=a.i;ea(a,ke(null,q($),null,q(ca))),x.a=!0;break;case 22:var ua=a.g,aa=a.g.k,ka=a.i;if(Ra(ua)){H(a,q(aa)),x.a=!0;return}if(Cb(ua)){H(a,q(ka)),x.a=!0;return}if(aa.b==ka.b&&Ac(aa.b)&&oa(aa.g,ka.g)&&aa.b^43){var va=aa.g,Ua=aa.i,la=ka.i,rb=n(n(n(new Jh(22),q(ua)),q(Ua)),q(la));H(a,n(n(new Jh(aa.b),q(va)),rb)),x.a=!0;return}if(aa.b==52&&oa(aa.g,ka)&&na(ka)){var La=aa.g,Va=aa.i,wa=n(n(n(new Jh(22),q(ua)),q(Va)),q(ka));H(a,n(n(new Jh(52),q(La)),wa)),x.a=!0;return}break;case 25:for(var xa=a.g,eb=null;xa!=a.i;xa=eb)eb=xa.k,na(xa)&&(q(xa),x.a=!0);if(a.l.b==25){ge(a),x.a=!0;return}if(fe(a)){H(a,q(a.g)),x.a=!0;return}break;case 31:var Ia=a.g;Ia.b^31?Ia.b^30?Ia.b^29||hc(x,a,-Ia.h):ic(x,a,-(Ia.h|0)|0):(H(a,q(Ia.g)),x.a=!0);break;case 32:var Ja=a.g;Ja.b^32?Ja.b^28||S(x,
a,!!!Ja.h):(H(a,q(Ja.g)),x.a=!0);break;case 33:H(a,q(a.g));break;case 38:var fb=a.g,sb=a.i;dc(fb,0)?(H(a,q(sb)),x.a=!0):dc(sb,0)?(H(a,q(fb)),x.a=!0):fb.b==30&&sb.b==30?ic(x,a,(fb.h|0)+(sb.h|0)|0):fb.b==29&&sb.b==29&&hc(x,a,fb.h+sb.h);break;case 39:var tb=a.g,bb=a.i;dc(bb,1)?(H(a,q(tb)),x.a=!0):tb.b==30&&bb.b==30?ic(x,a,bb.h|0?(tb.h|0)/(bb.h|0)|0:0):tb.b==29&&bb.b==29&&hc(x,a,bb.h!=0?tb.h/bb.h:0);break;case 40:var cb=a.g,Ub=a.i;oa(cb,Ub)&&na(cb)?(S(x,a,!0),x.a=!0):cb.b==30&&Ub.b==30?S(x,a,(cb.h|0)==(Ub.h|0)):cb.b==29&&Ub.b==29&&S(x,a,cb.h==Ub.h);break;case 41:var ub=a.g,jc=a.i;ub.b==30&&jc.b==30?S(x,a,(ub.h|0)>(jc.h|0)):ub.b==29&&jc.b==29&&S(x,a,ub.h>jc.h);break;case 42:var Ka=a.g,Wa=a.i;Ka.b^30?Wa.b^30?Ka.b==30&&Wa.b==30?S(x,a,(Ka.h|0)>=(Wa.h|0)):Ka.b==29&&Wa.b==29&&S(x,a,Ka.h>=Wa.h):(a.b=41,_(Wa,(Wa.h|0)-1|0),x.a=!0):(a.b=41,_(Ka,(Ka.h|0)+1|0),x.a=!0);break;case 43:var pc=a.g,kc=a.i,Oc=pc.f;if(kc.b==30){var Ob=kc.h|0,Pb=0;switch(Oc){case Lb:case vb:case Fa:Pb=2;break;case Mb:case wb:case Ga:Pb=3;break;case Nb:case xb:case Ha:
Pb=4;break}Ob>-1&&Ob<Pb&&(H(a,t(cc(n(new Jh(21),q(pc)),'xyzw'[Ob]),a.f)),x.a=!0)}break;case 44:var lc=a.g,Qb=a.i;lc.b==30&&Qb.b==30?S(x,a,(lc.h|0)<(Qb.h|0)):lc.b==29&&Qb.b==29&&S(x,a,lc.h<Qb.h);break;case 45:var Rb=a.g,yb=a.i;Rb.b^30?yb.b^30?Rb.b==30&&yb.b==30?S(x,a,(Rb.h|0)<=(yb.h|0)):Rb.b==29&&yb.b==29&&S(x,a,Rb.h<=yb.h):(a.b=44,_(yb,(yb.h|0)+1|0),x.a=!0):(a.b=44,_(Rb,(Rb.h|0)-1|0),x.a=!0);break;case 46:var Sb=a.g,Pc=a.i;Sb.b==28&&Ra(Sb)?(H(a,q(Pc)),x.a=!0):Sb.b==28&&Cb(Sb)?S(x,a,!1):Sb.b==28&&Pc.b==28&&S(x,a,!!Sb.h&&!!Pc.h);break;case 47:var Vb=a.g,qc=a.i;Vb.b==28&&Cb(Vb)?(H(a,q(qc)),x.a=!0):Vb.b==28&&Ra(Vb)?S(x,a,!0):Vb.b==28&&qc.b==28&&S(x,a,!!Vb.h&&!!qc.h);break;case 48:var Ta=a.g,mc=a.i;Ta.b==28&&mc.b==28&&S(x,a,!!Ta.h!=!!mc.h);break;case 49:var Ma=a.g,zb=a.i;Ma.b==30&&(Ma.h|0)==1?(H(a,q(zb)),x.a=!0):zb.b==30&&(zb.h|0)==1?(H(a,q(Ma)),x.a=!0):Ma.b==30&&zb.b==30?ic(x,a,qh(Ma.h|0,zb.h|0)):Ma.b==29&&zb.b==29&&hc(x,a,Ma.h*zb.h);break;case 50:var gb=a.g,nc=a.i;oa(gb,nc)&&na(gb)?(S(x,a,!1),x.a=!0):gb.b==30&&nc.b==30?S(x,
a,(gb.h|0)!=(nc.h|0)):gb.b==29&&nc.b==29&&S(x,a,gb.h!=nc.h);break;case 51:var Wb=a.g,Xb=a.i;dc(Wb,0)?(H(a,t(n(new Jh(31),q(Xb)),a.f)),x.a=!0):dc(Xb,0)?(H(a,q(Wb)),x.a=!0):Wb.b==30&&Xb.b==30?ic(x,a,(Wb.h|0)-(Xb.h|0)|0):Wb.b==29&&Xb.b==29&&hc(x,a,Wb.h-Xb.h);break}}function S(c,a,b){H(a,t(t(Ba(new Jh(28),b),Y),Y)),c.a=!0}function hc(c,a,b){H(a,t(t(ma(new Jh(29),b),da),Y)),c.a=!0}function ic(c,a,b){H(a,t(t(_(new Jh(30),b),ga),Y)),c.a=!0}function Ic(b,a){a.b==3&&fe(a)&&(ea(a,q(a.g)),b.a=!0)}function Fe(b,a){Na(b.c,a.c,a)}function Bg(b,a){Na(b.c,a.c,a)}function pd(c,a){var b=ya(c.c,a,null);return b||c.b&&pd(c.b,a)}function Cg(a){return new Qh(a,0,a.b.length)}function Dg(d,a){if(qd(d),a<0||a>=d.d.length)return'';var b=d.d[a],c=(a+1|0)<d.d.length?d.d[a+1|0]-1|0:d.b.length;return d.b.slice(b,c)}function Jb(h,a){qd(h);for(var b=h.d.length,c=0;b>0;){var d=b/2|0,e=c+d|0;h.d[e]<=a?(c=e+1|0,b=(b-d|0)-1|0):b=d}var f=c>0?a-h.d[c-1|0]|0:a;return new Wh(c-1|0,f)}function Kb(d,a,b){if(qd(d),a>-1&&a<d.d.length){var c=d.d[a];if(b>-1&&(c+b|0)<((a+1|0)<d.d.length?d.d[a+1|0]:d.b.length))return c+b|0}
return-1}function qd(b){if(!b.d){b.d=[0];for(var a=0,c=b.b.length;a<c;a=a+1|0)b.b.charCodeAt(a)^10||b.d.push(a+1|0)}}function rd(a){switch(a){case 2:return ch;case 3:return dh;case 4:return eh}return null}function sd(a,b){switch(a){case Y:switch(b){case 1:return Y;case 2:return Lb;case 3:return Mb;case 4:return Nb}break;case da:switch(b){case 1:return da;case 2:return Fa;case 3:return Ga;case 4:return Ha}break;case ga:switch(b){case 1:return ga;case 2:return vb;case 3:return wb;case 4:return xb}break}return null}function td(a){return a instanceof Ge&&(a.w==0||a.w==2)}function J(a){return a.l||(a.l=new _h(a,null,0)),a.l}function Eg(c,a){if(c.i.length^a.i.length)return!1;for(var b=0,d=c.i.length;b<d;b=b+1|0)if(c.i[b].p.f!=a.i[b].p.f)return!1;return!0}function N(a){var b;return (b=a.C)&&b.g}function Jc(a,b,c){for(var d=b.b.split(fh),e=[],f=null,h=0,m=0,l=0,C=d.length;l<C;l=l+1|0){var g=d[l],i=g.length,o=m+i|0,k=new Qh(b,m,o);if(l%2){var r=g.charCodeAt(0);if(r>64&&r<91||r>96&&r<123||r==95){var s=ya(Gg,g,99);s^99?e.push(new Zh(k,
s,f)):Hg.has(g)?Hf(a,k):e.push(new Zh(k,96,f))}else if(r>47&&r<58||r==46&&i>1)e.push(new Zh(k,gh.test(g)?97:95,f));else if(r^35){if(r^34){var p=ya(hh,g,99);p^99||(g.startsWith('//')?c^1?(f||(f=[])).push(k):p=0:g.startsWith('/*')&&(c^1?(f||(f=[])).push(k):p=1)),p^99&&e.push(new Zh(k,p,f))}else e.push(new Zh(k,98,f))}else{var w=94;switch(g){case'#version':w=92;break;case'#extension':w=91;break;case'#include':w=93;break}e.push(new Zh(k,w,f))}}else if(g!=''){u(a,k,'Syntax error "'+g+'"');break}e.length^h&&(f=null,h=e.length),m=o}return e.push(new Zh(new Qh(b,m,m),99,f)),e}function He(a){return a.b?He(a.b):a}function Ig(c,a){c.f||(c.f=new Map);var b=ra(c.f,a,null);return b||(za(c.f,a,b=new _h(null,c,a)),b.d=!0,b.e=c.e),b}function D(a){return a.b?a.c?D(a.b)+'['+a.c+']':D(a.b)+'[]':a.a.c}function Sa(a){switch(a){case Lb:case Fa:case vb:case ob:return 2;case Mb:case Ga:case wb:case pb:return 3;case Nb:case Ha:case xb:case qb:return 4}return a.c}function vd(a){switch(a){case Lb:case Mb:case Nb:return Y;case Fa:case Ga:case Ha:
return da;case vb:case wb:case xb:return ga;case ob:return Fa;case pb:return Ga;case qb:return Ha}return a.b}function Ea(a){switch(a){case Y:case da:case ga:return 1;case Lb:case Fa:case vb:return 2;case Mb:case Ga:case wb:return 3;case Nb:case Ha:case xb:case ob:return 4;case pb:return 9;case qb:return 16}return 0}function fa(a){switch(a){case Y:case Lb:case Mb:case Nb:return Y;case da:case Fa:case Ga:case Ha:case ob:case pb:case qb:return da;case ga:case vb:case wb:case xb:return ga}return null}function wd(a){switch(a){case Lb:case Mb:case Nb:case vb:case wb:case xb:case Fa:case Ga:case Ha:return!0}return!1}function ab(a){switch(a){case ob:case pb:case qb:return!0}return!1}function Kc(a){switch(a){case ga:case vb:case wb:case xb:return!0}return!1}function Lc(a){switch(a){case da:case Fa:case Ga:case Ha:return!0;case ob:case pb:case qb:return!0}return!1}function Jg(a){return Kc(a)||Lc(a)}function Kg(a){return !a.e&&!a.d}function Ie(a){return a.e=!0,a}function Je(b){var a=b.a.length;return b.a.push(a),a}function xd(c,a,b){
c.a[Mc(c,a)]=Mc(c,b)}function Mc(c,a){var b=c.a[a];return b^a&&(b=Mc(c,b),c.a[a]=b),b}function qa(a,b){Ke(a),process.stdout.write(b),Ke(0)}function Og(a){qa(3,'error: '),qa(1,a+'\n')}function Pg(a){qa(2,'note: '),qa(1,a+'\n')}function Qg(a){qa(7,'warning: '),qa(1,a+'\n')}function Le(a){for(var b=process.stdout.columns,l=0,g=a.a,i=g.length;l<i;l=l+1|0){var c=g[l];c.b&&qa(1,kd(c.b)+': ');switch(c.a){case 1:Qg(c.c);break;case 0:Og(c.c);break}if(c.b){var d=ld(c.b,b);qa(2,d.a+'\n'),qa(4,d.b+'\n')}if(c.d){qa(1,kd(c.d)+': '),Pg(c.e);var e=ld(c.d,b);qa(2,e.a+'\n'),qa(4,e.b+'\n')}}var f=a.c!=0,h=a.b!=0,m='';h&&(m+=a.b+' warning'+(a.b^1?'s':''),f&&(m+=' and ')),f&&(m+=a.c+' error'+(a.c^1?'s':'')),(h||f)&&process.stdout.write(m+' generated\n')}function Me(a){if(rh(a))return[new Xh('<stdin>',a)];if(a instanceof Array){for(var b=[],c=0,e=a.length;c<e;c=c+1|0){var d=a[c];b.push(new Xh(sh(d.name),sh(d.contents)))}return b}return[new Xh(sh(a.name),sh(a.contents))]}function Ne(a){return function(b,c){var d=a(b,c);if(rh(d))return new Xh(b,
d);if(!d)return null;var e=d.name,f=d.contents;if(rh(e)&&rh(f))return new Xh(e,f);throw new Error('Invalid file access result')}}function Rg(){var a=process.argv.slice(2),b=new th,c=[],d=0,e=null,f=require('fs'),h=require('path');b.e=function(m,l){var g=h.resolve(h.dirname(l),m);try{return new Xh(g,f.readFileSync(g,'utf8'))}catch(C){}return null};for(var w=0,p=a.length;w<p;w=w+1|0){var i=a[w];if(i.startsWith('-'))switch(i){case'--disable-rewriting':b.a=!1;break;case'--pretty-print':b.b=!1;break;case'--keep-symbols':b.d=!1;break;case'--help':case'-h':console.log("\nUsage: glslx [sources] [flags]\n\n  --output=PATH\n    Set the path to the output file. Defaults to standard out.\n\n  --format=FORMAT\n    Set the output format, must be json, js, c++, skew or rust. Defaults to json.\n\nAdvanced:\n\n  --disable-rewriting\n    Disable syntax tree rewriting, useful to check for driver bugs.\n\n  --pretty-print\n    Format the output nicely instead of minifying it.\n\n  --renaming=MODE\n    Valid modes are all, internal-only, or none. Defaults to all.\n\n  --keep-symbols\n    Don't inline constants or remove unused symbols.\n");
return;default:if(i.startsWith('--output='))e=i.slice(9);else if(i.startsWith('--format=')){var o=i.slice(9);Qe.has(o)||(console.log('invalid output format "'+o+'"'),process.exit(1)),d=Qe.get(o)}else if(i.startsWith('--renaming=')){var k=i.slice(11);Re.has(k)||(console.log('invalid symbol renaming mode "'+k+'"'),process.exit(1)),b.c=Re.get(k)}else console.log('invalid flag "'+i+'"'),process.exit(1);break}else c.push(new Xh(h.resolve(i),f.readFileSync(i,'utf8')))}if(c.length){var r=new Ih,s=Gd(r,c,b);s?e!=null?(f.writeFileSync(e,Sc(s,d)),Le(r)):process.stdout.write(Sc(s,d)):(Le(r),process.exit(1))}else console.log("\nUsage: glslx [sources] [flags]\n\n  --output=PATH\n    Set the path to the output file. Defaults to standard out.\n\n  --format=FORMAT\n    Set the output format, must be json, js, c++, skew or rust. Defaults to json.\n\nAdvanced:\n\n  --disable-rewriting\n    Disable syntax tree rewriting, useful to check for driver bugs.\n\n  --pretty-print\n    Format the output nicely instead of minifying it.\n\n  --renaming=MODE\n    Valid modes are all, internal-only, or none. Defaults to all.\n\n  --keep-symbols\n    Don't inline constants or remove unused symbols.\n")}
function ai(){var a=(function(){return this})(),b=typeof exports!=='undefined'?exports:a.GLSLX={};b.compile=jh,b.compileIDE=kh,b.format=lh,typeof require!=='undefined'&&typeof module!=='undefined'&&require.main===module&&Rg()}function cd(a){return a>27&&a<31}function dd(a){return a>30&&a<38}function Rf(a){return a>30&&a<36}function ed(a){return a>33&&a<38}function Ac(a){return a>37&&a<57}function Bc(a){return a>51&&a<57}function Sf(a){return a==4||a==5||a==6||a==15}function ce(a){return a==7||a==10||a==19}function $a(b){var a='';return b&1&&(a+='attribute '),b&2&&(a+='const '),b&256&&(a+='uniform '),b&512&&(a+='varying '),b&4&&(a+='highp '),b&32&&(a+='lowp '),b&64&&(a+='mediump '),b&8&&(a+='in '),b&16&&(a+='inout '),b&128&&(a+='out '),a}function Fg(a){return a>49&&a<80}function ud(a){switch(a){case 96:case 42:case 33:case 34:case 14:case 39:case 40:case 41:case 20:case 22:case 23:case 24:case 3:case 5:case 6:case 7:case 26:case 27:case 28:return!0}return!1}function Ke(a){process.stdout.isTTY&&process.stdout.write('\x1B[0;'+ih.get(a)+'m')}
function hb(b,a){return b[b.length-1|0]=a}function Rc(a){return a[a.length-1|0]}function Ze(c,a){for(var d=0,e=a.length;d<e;d=d+1|0){var b=a[d];c.push(b)}}function Ab(d,a){for(var b=0,c=0,e=d.length;c<e;c=c+1|0)a(d[c])||(b<c&&(d[b]=d[c]),b=b+1|0);for(;b<d.length;)d.pop()}function Na(c,a,b){return c.set(a,b),b}function j(c,a,b){return c.set(a,b),c}function ya(d,a,b){var c=d.get(a);return c!==void 0?c:b}function za(c,a,b){return c.set(a,b),b}function Oa(c,a,b){return c.set(a,b),c}function ra(d,a,b){var c=d.get(a);return c!==void 0?c:b}function Qc(b,a){return (a<b|0)-(a>b|0)|0}function rc(a){for(var b=new nh,d=0,e=a.length;d<e;d=d+1|0){var c=a[d];b.a+=We(c)}return b.a}function Ye(b,a){return (a<b|0)-(a>b|0)|0}function Yb(d,a){for(var b='',c=0;c<a;c=c+1|0)b+=d;return b}function We(a){return a<65536?String.fromCharCode(a):String.fromCharCode((a-65536>>10)+55296|0)+String.fromCharCode((a-65536&1023)+56320|0)}function Nc(a){if(!a)return null;var b=a.a,c=Jb(b,a.b),d=Jb(b,a.c);return{source:b.a,start:{line:c.a,column:c.b},
end:{line:d.a,column:d.b}}}function jh(a,b){b=b||{};var c=Me(a),d=new Ih,e=new th;e.c=ya(Re,b.renaming,0),b.disableRewriting&&(e.a=!1),b.prettyPrint&&(e.b=!1),b.keepSymbols&&(e.d=!1),b.fileAccess&&(e.e=Ne(b.fileAccess));var f=Gd(d,c,e);return{log:Ff(d),output:f?Sc(f,ya(Qe,b.format,0)):null}}function kh(a,b){b=b||{};var c=Me(a),d=new Ih,e=new th;b.fileAccess&&(e.e=Ne(b.fileAccess));var f=_e(d,c,e),h=function(m){for(var Xb,l=m.source+'',g=m.line|0,i=m.column|0,o=!!m.ignoreDiagnostics,k=null,r=null,s=null,zd=0,Ug=c.length;zd<Ug;zd=zd+1|0){var w=c[zd];if(w.a==l){var p=Kb(w,g,i);if(~p){if(!o&&d)for(var x=0,Se=d.a,Tg=Se.length;x<Tg;x=x+1|0){var C=Se[x];if(C.b&&C.b.a==w&&gc(C.b,p)){r=new zh(C.c,''),k=C.b;break}}if(!r&&f){var B=new Ah(w,p);Pa(B,f.a),r=yf(B),r&&(k=B.e,s=(Xb=B.d)&&Xb.c)}}break}}return{tooltip:r&&r.a,range:Nc(k),symbol:s,documentation:r&&r.b}},U=function(F){for(var Q=F.source+'',ia=F.line|0,M=F.column|0,ha=null,Z=null,$=null,Ad=0,Te=f.b,Vg=Te.length;Ad<Vg;Ad=Ad+1|0){var ca=Te[Ad];if(ca.a.a.a==Q){var ua=Kb(ca.a.a,
ia,M);if(~ua&&gc(ca.a,ua))return{definition:Nc(ca.b),range:Nc(ca.a),symbol:ca.b.a.a}}}for(var Bd=0,Wg=c.length;Bd<Wg;Bd=Bd+1|0){var aa=c[Bd];if(aa.a==Q){var ka=Kb(aa,ia,M);if(~ka&&f){var va=new Ah(aa,ka);Pa(va,f.a),va.d&&va.d.b&&va.d.b.a.a!='<api>'&&(Z=va.d.b,ha=va.e,$=va.d.c)}break}}return{definition:Nc(Z),range:Nc(ha),symbol:$}},Ua=function(la){for(var rb=la.source+'',La=null,Cd=0,Xg=c.length;Cd<Xg;Cd=Cd+1|0){var Va=c[Cd];if(Va.a==rb){if(f){var wa=new Bh(Va);Xd(wa,f.a),La=wa.b.map(function(xa){return{name:xa.c,kind:xa instanceof Ge?'variable':xa instanceof oc?'function':xa instanceof Tb?'struct':null,range:Nc(xa.b)}})}break}}return{symbols:La}},eb=function(Ia){for(var Ja=Ia.source+'',fb=Ia.line|0,sb=Ia.column|0,tb=null,bb=null,Dd=0,Yg=c.length;Dd<Yg;Dd=Dd+1|0){var cb=c[Dd];if(cb.a==Ja){var Ub=Kb(cb,fb,sb);if(~Ub&&f){var ub=new Ch(cb,Ub);Bf(ub,f.a),ub.d&&ub.d.b&&ub.d.b.a.a!='<api>'&&(tb=ub.c.map(Nc),bb=ub.d.c)}break}}return{ranges:tb,symbol:bb}},jc=function(Ka){for(var Wa=Ka.source+'',pc=Ka.line|0,kc=Ka.column|0,Oc=[],Ed=0,Zg=c.length;Ed<Zg;Ed=Ed+1|0){
var Ob=c[Ed];if(Ob.a==Wa){var Pb=Kb(Ob,pc,kc);if(~Pb&&f){var lc=new Eh(Ob,Pb);Ef(lc,f.a),Oc=lc.d.map(function(Qb){return{kind:Qb.a,name:Qb.b,detail:Qb.c,documentation:Qb.d}})}}}return{completions:Oc}},Rb=function(yb){for(var Sb=yb.source+'',Pc=yb.line|0,Vb=yb.column|0,qc=[],Ta=-1,mc=-1,Fd=0,_g=c.length;Fd<_g;Fd=Fd+1|0){var Ma=c[Fd];if(Ma.a==Sb){var zb=Kb(Ma,Pc,Vb);if(~zb&&f){var gb=new Gh(Ma,zb);ad(gb,f.a),Ta=gb.d,mc=gb.e,qc=gb.c.map(function(nc){return{text:nc.a,'arguments':nc.b,documentation:nc.c}})}}}return{signatures:qc,activeArgument:Ta,activeSignature:mc}};return{diagnostics:d.a.map(function(Wb){return{kind:mh[Wb.a].toLowerCase(),range:Nc(Wb.b),text:Wb.c}}),tooltipQuery:h,definitionQuery:U,symbolsQuery:Ua,renameQuery:eb,completionQuery:jc,signatureQuery:Rb}}function lh(a,b){b=b||{};var c='indent'in b?sh(b.indent):'  ',d='newline'in b?sh(b.newline):'\n',e=2;if('trailingNewline'in b){var f=sh(b.trailingNewline);switch(f){case'preserve':e=0;break;case'remove':e=1;break;case'insert':e=2;break;default:throw new Error('Invalid "trailingNewline" value: '+f)}}
return xf(sh(a),c,d,e)}function nh(){this.a=''}function oh(){this.a='',this.b=0,this.c=0}function th(){this.a=!0,this.b=!0,this.c=0,this.d=!0,this.e=null}function uh(a){this.a=new Map,this.b=a,this.c=0}function vh(a,b){this.a=a,this.b=b}function wh(a,b){this.a=a,this.b=b}function xh(){this.a=[],this.b=[]}function yh(a,b){this.a='',this.b='',this.c='\n',this.d=' ',this.e=b.b,this.e&&(this.d='',this.c='');for(var c=null,d=a.g;d;d=d.k)ef(this,d)||(c&&df(c,d)&&(this.a+=this.c),Xa(this,d),this.a+=this.c,c=d)}function zh(a,b){this.a=a,this.b=b}function Ah(a,b){this.a=a,this.b=b,this.c=null,this.d=null,this.e=null,this.f=null,this.h=null}function Bh(a){this.a=a,this.b=[]}function Ch(a,b){this.a=a,this.b=b,this.c=[],this.d=null}function Dh(a,b){this.a=a,this.b=b,this.c='',this.d=''}function Eh(a,b){this.a=a,this.b=b,this.c=new Map,this.d=[]}function Fh(a,b,c){this.a=a,this.b=b,this.c=c}function Gh(a,b){this.a=a,this.b=b,this.c=[],this.d=-1,this.e=-1}function Hh(a,b,c){this.a=a,this.b=b,this.c=c,this.d=null,this.e=''}function Ih(){
this.a=[],this.b=0,this.c=0,this.d=null}function Jh(a){this.a=le(),this.b=a,this.c=null,this.d=null,this.e=null,this.f=null,this.h=0,this.m=null,this.l=null,this.g=null,this.i=null,this.o=null,this.k=null,this.r=!1}function Kh(a){this.a=a}function Lh(a,b){this.a=a,this.b=b}function Mh(a,b,c,d,e){this.a=a,this.b=b,this.c=c,this.d=d,this.e=e,this.f=[],this.h=0,this.m=0,this.l=null}function Nh(a){this.a=a,this.b=null,this.c=null}function Oh(){this.a=new Map}function Ph(a,b){this.a=a,this.b=b}function Qh(a,b,c){this.a=a,this.b=b,this.c=c}function Sh(a,b){this.a=a,this.b=b,this.c=new Map,this.d=0,this.e=!1}function Rh(a){this.a=a,this.b=[],this.c=[],this.d=new Map,this.e=new $h,this.f=new $h,this.h=0,this.m=0,this.l=-1}function Th(a,b){this.a=a,this.b=b,this.c=new xh,this.d=[],this.e=new Map,this.f=null}function Uh(){this.a=!1,this.b=[],this.c=new Map,this.d=new Map,this.e=new Map}function Vh(a,b){this.a=a,this.b=b,this.c=new Map}function Wh(a,b){this.a=a,this.b=b}function Xh(a,b){this.a=a,this.b=b,this.c=null,this.d=null}
function Yh(a,b,c,d){this.a=a,this.b=b,this.c=c,this.d=d,this.e=0,this.f=null,this.h=null,this.m=null,this.l=null}function Tb(a,b,c,d){Yh.call(this,a,b,c,d),this.g=[]}ph(Tb,Yh);function oc(a,b,c,d){Yh.call(this,a,b,c,d),this.i=[],this.o=null,this.k=null,this.r=null,this.s=null}ph(oc,Yh);function Ge(a,b,c,d,e){Yh.call(this,a,b,c,d),this.w=e,this.p=null,this.C=null,this.B=null}ph(Ge,Yh);function Zh(a,b,c){this.a=a,this.b=b,this.c=c}function _h(a,b,c){this.a=a,this.b=b,this.c=c,this.d=!1,this.e=!1,this.f=null}function $h(){this.a=[]}var $g=new oh,Pe=0,db=null,ag=j(j(j(j(new Map,'disable',1),'enable',2),'require',3),'warn',4),bh=j(j(j(j(new Map,'GL_OES_standard_derivatives',0),'GL_EXT_frag_depth',0),'GL_EXT_draw_buffers',0),'GL_EXT_shader_texture_lod',0),ch=['xy','st','rg'],dh=['xyz','stp','rgb'],eh=['xyzw','stpq','rgba'],fh=new RegExp('(\\.[0-9]+[eE][+-]?[0-9]+\\b|\\.[0-9]+\\b|[0-9]+\\.[0-9]+[eE][+-]?[0-9]+\\b|[0-9]+\\.[0-9]+\\b|[0-9]+\\.[eE][+-]?[0-9]+\\b|[0-9]+\\.|[0-9]+[eE][+-]?[0-9]+\\b|[1-9][0-9]*\\b|0[0-7]*\\b|0[xX][0-9A-Fa-f]+\\b|[ \t\r\n]|/\\*(?:.|\r\n|\n)*?\\*/|//.*|&&|\\|\\||\\^\\^|\\+\\+|--|<<=?|>>=?|[()[\\]{}\\.,?:;]|[+\\-*/%=!<>&|^~]=?|[A-Za-z_][A-Za-z0-9_]*\\b|#\\w+\\b|"(?:[^"\\\\]|\\\\.)*")'),gh=new RegExp('^([1-9][0-9]*|0[0-7]*|0[xX][0-9A-Fa-f]+)$'),Gg=j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(new Map,
'attribute',2),'bool',3),'break',4),'bvec2',5),'bvec3',6),'bvec4',7),'const',8),'continue',9),'discard',10),'do',11),'else',12),'false',13),'float',14),'for',15),'highp',16),'if',17),'in',18),'inout',19),'int',20),'invariant',21),'ivec2',22),'ivec3',23),'ivec4',24),'lowp',25),'mat2',26),'mat3',27),'mat4',28),'mediump',29),'out',30),'precision',31),'return',32),'sampler2D',33),'samplerCube',34),'struct',35),'true',36),'uniform',37),'varying',38),'vec2',39),'vec3',40),'vec4',41),'void',42),'while',43),'export',44),'import',45),hh=j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(new Map,'~',46),'--',47),'++',48),'!',49),'&',50),'|',51),'^',52),'/',53),'==',54),'>',55),'>=',56),'<',57),'<=',58),'&&',59),'||',60),'^^',61),'-',62),'*',63),'!=',64),'+',65),'%',66),'<<',67),'>>',68),'=',69),'+=',70),'&=',71),'|=',72),'^=',73),'/=',74),'*=',75),'%=',76),'<<=',77),'>>=',78),'-=',79),':',80),',',81),'.',82),'{',83),'[',84),'(',85),'?',86),'}',87),']',88),')',89),';',90),Hg=j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(j(new Map,
'asm',0),'cast',0),'class',0),'default',0),'double',0),'dvec2',0),'dvec3',0),'dvec4',0),'enum',0),'extern',0),'external',0),'fixed',0),'flat',0),'fvec2',0),'fvec3',0),'fvec4',0),'goto',0),'half',0),'hvec2',0),'hvec3',0),'hvec4',0),'inline',0),'input',0),'interface',0),'long',0),'namespace',0),'noinline',0),'output',0),'packed',0),'public',0),'sampler1D',0),'sampler1DShadow',0),'sampler2DRect',0),'sampler2DRectShadow',0),'sampler2DShadow',0),'sampler3D',0),'sampler3DRect',0),'short',0),'sizeof',0),'static',0),'superp',0),'switch',0),'template',0),'this',0),'typedef',0),'union',0),'unsigned',0),'using',0),'volatile',0),Y=J(new Tb(-1,null,'bool',null)),Lb=J(new Tb(-2,null,'bvec2',null)),Mb=J(new Tb(-3,null,'bvec3',null)),Nb=J(new Tb(-4,null,'bvec4',null)),K=J(new Tb(-5,null,'<error>',null)),da=J(new Tb(-6,null,'float',null)),ga=J(new Tb(-7,null,'int',null)),vb=J(new Tb(-8,null,'ivec2',null)),wb=J(new Tb(-9,null,'ivec3',null)),xb=J(new Tb(-10,null,'ivec4',null)),ob=J(new Tb(-11,null,'mat2',null)),pb=J(new Tb(-12,null,
'mat3',null)),qb=J(new Tb(-13,null,'mat4',null)),Lg=Ie(J(new Tb(-14,null,'sampler2D',null))),Mg=Ie(J(new Tb(-15,null,'samplerCube',null))),Fa=J(new Tb(-16,null,'vec2',null)),Ga=J(new Tb(-17,null,'vec3',null)),Ha=J(new Tb(-18,null,'vec4',null)),yd=J(new Tb(-19,null,'void',null)),Ng=[Y,Lb,Mb,Nb,da,ga,vb,wb,xb,ob,pb,qb,Lg,Mg,Fa,Ga,Ha],Qe=j(j(j(j(j(new Map,'json',0),'js',1),'c++',2),'skew',3),'rust',4),Re=j(j(j(new Map,'all',0),'internal-only',1),'none',2),mh=['ERROR','WARNING'],Sg=['GLOBAL','STRUCT_BLOCK','VARIABLE','BLOCK','BREAK','CONTINUE','DISCARD','DO_WHILE','EXPRESSION','EXTENSION','FOR','FUNCTION','IF','MODIFIER_BLOCK','PRECISION','RETURN','STRUCT','VARIABLES','VERSION','WHILE','CALL','DOT','HOOK','NAME','PARSE_ERROR','SEQUENCE','TYPE','UNKNOWN_CONSTANT','BOOL','FLOAT','INT','NEGATIVE','NOT','POSITIVE','PREFIX_DECREMENT','PREFIX_INCREMENT','POSTFIX_DECREMENT','POSTFIX_INCREMENT','ADD','DIVIDE','EQUAL','GREATER_THAN','GREATER_THAN_OR_EQUAL','INDEX','LESS_THAN','LESS_THAN_OR_EQUAL','LOGICAL_AND','LOGICAL_OR',
'LOGICAL_XOR','MULTIPLY','NOT_EQUAL','SUBTRACT','ASSIGN','ASSIGN_ADD','ASSIGN_DIVIDE','ASSIGN_MULTIPLY','ASSIGN_SUBTRACT'],Oe=['SINGLE_LINE_COMMENT','MULTI_LINE_COMMENT','ATTRIBUTE','BOOL','BREAK','BVEC2','BVEC3','BVEC4','CONST','CONTINUE','DISCARD','DO','ELSE','FALSE','FLOAT','FOR','HIGHP','IF','IN','INOUT','INT','INVARIANT','IVEC2','IVEC3','IVEC4','LOWP','MAT2','MAT3','MAT4','MEDIUMP','OUT','PRECISION','RETURN','SAMPLER2D','SAMPLERCUBE','STRUCT','TRUE','UNIFORM','VARYING','VEC2','VEC3','VEC4','VOID','WHILE','EXPORT','IMPORT','COMPLEMENT','DECREMENT','INCREMENT','NOT','BITWISE_AND','BITWISE_OR','BITWISE_XOR','DIVIDE','EQUAL','GREATER_THAN','GREATER_THAN_OR_EQUAL','LESS_THAN','LESS_THAN_OR_EQUAL','LOGICAL_AND','LOGICAL_OR','LOGICAL_XOR','MINUS','MULTIPLY','NOT_EQUAL','PLUS','REMAINDER','SHIFT_LEFT','SHIFT_RIGHT','ASSIGN','ASSIGN_ADD','ASSIGN_BITWISE_AND','ASSIGN_BITWISE_OR','ASSIGN_BITWISE_XOR','ASSIGN_DIVIDE','ASSIGN_MULTIPLY','ASSIGN_REMAINDER','ASSIGN_SHIFT_LEFT','ASSIGN_SHIFT_RIGHT','ASSIGN_SUBTRACT','COLON',
'COMMA','DOT','LEFT_BRACE','LEFT_BRACKET','LEFT_PARENTHESIS','QUESTION','RIGHT_BRACE','RIGHT_BRACKET','RIGHT_PARENTHESIS','SEMICOLON','EXTENSION','VERSION','INCLUDE','PRAGMA','FLOAT_LITERAL','IDENTIFIER','INT_LITERAL','STRING_LITERAL','END_OF_FILE'],ih=Oa(Oa(Oa(Oa(Oa(Oa(Oa(Oa(Oa(new Map,0,0),1,1),2,90),3,31),4,32),5,33),6,34),7,35),8,36);ai()})();